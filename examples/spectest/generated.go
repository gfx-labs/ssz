// Code generated by genssz. DO NOT EDIT.

package spectest

import (
	"encoding/binary"
	"fmt"
	"github.com/gfx-labs/ssz"
	"github.com/gfx-labs/ssz/merkle_tree"
	"github.com/gfx-labs/ssz/merkle_tree/bufpool"
)

// Checkpoint is a fixed-size SSZ container with the following byte layout:
//
// Byte layout:
// [  0-  7]  epoch (uint64)
// [  8- 39]  root (bytevector[32])
// Total size: 40 bytes
type Checkpoint []byte

// NewCheckpoint creates a new Checkpoint with the specified size
func NewCheckpoint() Checkpoint {
	return make([]byte, 40)
}

// NewCheckpointWithValues creates a new Checkpoint with the provided values
// Parameters:
//   - epoch: uint64 value
//   - root: bytevector[32] value
func NewCheckpointWithValues(epoch uint64, root [32]byte) Checkpoint {
	obj := NewCheckpoint()
	obj.SetEpoch(epoch)
	obj.SetRoot(root)
	return obj
}

// Fixed returns true if the type is fixed size
func (s Checkpoint) Fixed() bool {
	return true
}

// SizeSSZ returns the size of the serialized object
func (s Checkpoint) SizeSSZ() int {
	return 40
}

// MarshalSSZ returns the bytes
func (s Checkpoint) MarshalSSZ() ([]byte, error) {
	// Check that the length matches the expected size
	if len(s) != s.SizeSSZ() {
		return nil, ssz.NewErrSizeMismatch(s.SizeSSZ(), len(s))
	}
	return s, nil
}

// FillHashBuffer fills the provided buffer with hashes of all fields
func (s Checkpoint) FillHashBuffer(buf []byte) error {
	// Ensure buffer is large enough
	if len(buf) < 64 {
		return fmt.Errorf("buffer too small: need %d bytes, got %d", 64, len(buf))
	}

	// Hash each field and store in buffer
	// Field epoch (uint64)
	copy(buf[0:8], s[0:8])
	for j := 8; j < 32; j++ {
		buf[j] = 0
	}

	// Field root (bytevector, size 32)
	copy(buf[32:64], s[8:40])

	return nil
}

// HashSSZTo writes the merkle tree hash of the object to the provided buffer
func (s Checkpoint) HashSSZTo(buf []byte) ([]byte, error) {
	// Ensure buffer has at least 32 bytes
	if len(buf) < 32 {
		return nil, fmt.Errorf("buffer too small: need at least 32 bytes, got %d", len(buf))
	}
	// Get hash buffer from pool
	numFields := 2
	poolBuf := bufpool.Get(numFields * 32)
	defer bufpool.Put(poolBuf)
	hashBuffer := poolBuf.B[:numFields*32]
	// Fill the hash buffer with field hashes
	if err := s.FillHashBuffer(hashBuffer); err != nil {
		return nil, err
	}
	// Compute merkle root from the field hashes
	if err := merkle_tree.ComputeMerkleRoot(hashBuffer, hashBuffer); err != nil {
		return nil, err
	}
	// Copy the root hash to the provided buffer
	copy(buf, hashBuffer[:32])
	return buf[:32], nil
}

// HashSSZ returns the merkle tree hash of the object
func (s Checkpoint) HashSSZ() (hash [32]byte, err error) {
	_, err = s.HashSSZTo(hash[:])
	return
}

// Epoch returns the epoch field
// Bytes: 0-7
func (s Checkpoint) Epoch() uint64 {
	return binary.LittleEndian.Uint64(s[0:8])
}

// Root returns the root field
// Bytes: 8-39
func (s Checkpoint) Root() [32]byte {
	return [32]byte(s[8:40])
}

// SetEpoch sets the epoch field
// Bytes: 0-7
func (s Checkpoint) SetEpoch(v uint64) {
	binary.LittleEndian.PutUint64(s[0:8], v)
}

// SetRoot sets the root field
// Bytes: 8-39
func (s Checkpoint) SetRoot(v [32]byte) {
	copy(s[8:40], v[:])
}

// Fork is a fixed-size SSZ container with the following byte layout:
//
// Byte layout:
// [  0-  3]  previousVersion (bytevector[4])
// [  4-  7]  currentVersion (bytevector[4])
// [  8- 15]  epoch (uint64)
// Total size: 16 bytes
type Fork []byte

// NewFork creates a new Fork with the specified size
func NewFork() Fork {
	return make([]byte, 16)
}

// NewForkWithValues creates a new Fork with the provided values
// Parameters:
//   - previousVersion: bytevector[4] value
//   - currentVersion: bytevector[4] value
//   - epoch: uint64 value
func NewForkWithValues(previousVersion [4]byte, currentVersion [4]byte, epoch uint64) Fork {
	obj := NewFork()
	obj.SetPreviousVersion(previousVersion)
	obj.SetCurrentVersion(currentVersion)
	obj.SetEpoch(epoch)
	return obj
}

// Fixed returns true if the type is fixed size
func (s Fork) Fixed() bool {
	return true
}

// SizeSSZ returns the size of the serialized object
func (s Fork) SizeSSZ() int {
	return 16
}

// MarshalSSZ returns the bytes
func (s Fork) MarshalSSZ() ([]byte, error) {
	// Check that the length matches the expected size
	if len(s) != s.SizeSSZ() {
		return nil, ssz.NewErrSizeMismatch(s.SizeSSZ(), len(s))
	}
	return s, nil
}

// FillHashBuffer fills the provided buffer with hashes of all fields
func (s Fork) FillHashBuffer(buf []byte) error {
	// Ensure buffer is large enough
	if len(buf) < 96 {
		return fmt.Errorf("buffer too small: need %d bytes, got %d", 96, len(buf))
	}

	// Hash each field and store in buffer
	// Field previousVersion (bytevector, size 4)
	copy(buf[0:4], s[0:4])
	for j := 4; j < 32; j++ {
		buf[j] = 0
	}

	// Field currentVersion (bytevector, size 4)
	copy(buf[32:36], s[4:8])
	for j := 36; j < 64; j++ {
		buf[j] = 0
	}

	// Field epoch (uint64)
	copy(buf[64:72], s[8:16])
	for j := 72; j < 96; j++ {
		buf[j] = 0
	}

	return nil
}

// HashSSZTo writes the merkle tree hash of the object to the provided buffer
func (s Fork) HashSSZTo(buf []byte) ([]byte, error) {
	// Ensure buffer has at least 32 bytes
	if len(buf) < 32 {
		return nil, fmt.Errorf("buffer too small: need at least 32 bytes, got %d", len(buf))
	}
	// Get hash buffer from pool
	numFields := 3
	poolBuf := bufpool.Get(numFields * 32)
	defer bufpool.Put(poolBuf)
	hashBuffer := poolBuf.B[:numFields*32]
	// Fill the hash buffer with field hashes
	if err := s.FillHashBuffer(hashBuffer); err != nil {
		return nil, err
	}
	// Compute merkle root from the field hashes
	if err := merkle_tree.ComputeMerkleRoot(hashBuffer, hashBuffer); err != nil {
		return nil, err
	}
	// Copy the root hash to the provided buffer
	copy(buf, hashBuffer[:32])
	return buf[:32], nil
}

// HashSSZ returns the merkle tree hash of the object
func (s Fork) HashSSZ() (hash [32]byte, err error) {
	_, err = s.HashSSZTo(hash[:])
	return
}

// PreviousVersion returns the previousVersion field
// Bytes: 0-3
func (s Fork) PreviousVersion() [4]byte {
	return [4]byte(s[0:4])
}

// CurrentVersion returns the currentVersion field
// Bytes: 4-7
func (s Fork) CurrentVersion() [4]byte {
	return [4]byte(s[4:8])
}

// Epoch returns the epoch field
// Bytes: 8-15
func (s Fork) Epoch() uint64 {
	return binary.LittleEndian.Uint64(s[8:16])
}

// SetPreviousVersion sets the previousVersion field
// Bytes: 0-3
func (s Fork) SetPreviousVersion(v [4]byte) {
	copy(s[0:4], v[:])
}

// SetCurrentVersion sets the currentVersion field
// Bytes: 4-7
func (s Fork) SetCurrentVersion(v [4]byte) {
	copy(s[4:8], v[:])
}

// SetEpoch sets the epoch field
// Bytes: 8-15
func (s Fork) SetEpoch(v uint64) {
	binary.LittleEndian.PutUint64(s[8:16], v)
}

// Eth1Data is a fixed-size SSZ container with the following byte layout:
//
// Byte layout:
// [  0- 31]  depositRoot (bytevector[32])
// [ 32- 39]  depositCount (uint64)
// [ 40- 71]  blockHash (bytevector[32])
// Total size: 72 bytes
type Eth1Data []byte

// NewEth1Data creates a new Eth1Data with the specified size
func NewEth1Data() Eth1Data {
	return make([]byte, 72)
}

// NewEth1DataWithValues creates a new Eth1Data with the provided values
// Parameters:
//   - depositRoot: bytevector[32] value
//   - depositCount: uint64 value
//   - blockHash: bytevector[32] value
func NewEth1DataWithValues(depositRoot [32]byte, depositCount uint64, blockHash [32]byte) Eth1Data {
	obj := NewEth1Data()
	obj.SetDepositRoot(depositRoot)
	obj.SetDepositCount(depositCount)
	obj.SetBlockHash(blockHash)
	return obj
}

// Fixed returns true if the type is fixed size
func (s Eth1Data) Fixed() bool {
	return true
}

// SizeSSZ returns the size of the serialized object
func (s Eth1Data) SizeSSZ() int {
	return 72
}

// MarshalSSZ returns the bytes
func (s Eth1Data) MarshalSSZ() ([]byte, error) {
	// Check that the length matches the expected size
	if len(s) != s.SizeSSZ() {
		return nil, ssz.NewErrSizeMismatch(s.SizeSSZ(), len(s))
	}
	return s, nil
}

// FillHashBuffer fills the provided buffer with hashes of all fields
func (s Eth1Data) FillHashBuffer(buf []byte) error {
	// Ensure buffer is large enough
	if len(buf) < 96 {
		return fmt.Errorf("buffer too small: need %d bytes, got %d", 96, len(buf))
	}

	// Hash each field and store in buffer
	// Field depositRoot (bytevector, size 32)
	copy(buf[0:32], s[0:32])

	// Field depositCount (uint64)
	copy(buf[32:40], s[32:40])
	for j := 40; j < 64; j++ {
		buf[j] = 0
	}

	// Field blockHash (bytevector, size 32)
	copy(buf[64:96], s[40:72])

	return nil
}

// HashSSZTo writes the merkle tree hash of the object to the provided buffer
func (s Eth1Data) HashSSZTo(buf []byte) ([]byte, error) {
	// Ensure buffer has at least 32 bytes
	if len(buf) < 32 {
		return nil, fmt.Errorf("buffer too small: need at least 32 bytes, got %d", len(buf))
	}
	// Get hash buffer from pool
	numFields := 3
	poolBuf := bufpool.Get(numFields * 32)
	defer bufpool.Put(poolBuf)
	hashBuffer := poolBuf.B[:numFields*32]
	// Fill the hash buffer with field hashes
	if err := s.FillHashBuffer(hashBuffer); err != nil {
		return nil, err
	}
	// Compute merkle root from the field hashes
	if err := merkle_tree.ComputeMerkleRoot(hashBuffer, hashBuffer); err != nil {
		return nil, err
	}
	// Copy the root hash to the provided buffer
	copy(buf, hashBuffer[:32])
	return buf[:32], nil
}

// HashSSZ returns the merkle tree hash of the object
func (s Eth1Data) HashSSZ() (hash [32]byte, err error) {
	_, err = s.HashSSZTo(hash[:])
	return
}

// DepositRoot returns the depositRoot field
// Bytes: 0-31
func (s Eth1Data) DepositRoot() [32]byte {
	return [32]byte(s[0:32])
}

// DepositCount returns the depositCount field
// Bytes: 32-39
func (s Eth1Data) DepositCount() uint64 {
	return binary.LittleEndian.Uint64(s[32:40])
}

// BlockHash returns the blockHash field
// Bytes: 40-71
func (s Eth1Data) BlockHash() [32]byte {
	return [32]byte(s[40:72])
}

// SetDepositRoot sets the depositRoot field
// Bytes: 0-31
func (s Eth1Data) SetDepositRoot(v [32]byte) {
	copy(s[0:32], v[:])
}

// SetDepositCount sets the depositCount field
// Bytes: 32-39
func (s Eth1Data) SetDepositCount(v uint64) {
	binary.LittleEndian.PutUint64(s[32:40], v)
}

// SetBlockHash sets the blockHash field
// Bytes: 40-71
func (s Eth1Data) SetBlockHash(v [32]byte) {
	copy(s[40:72], v[:])
}

// Validator is a fixed-size SSZ container with the following byte layout:
//
// Byte layout:
// [  0- 47]  pubkey (bytevector[48])
// [ 48- 79]  withdrawalCredentials (bytevector[32])
// [ 80- 87]  effectiveBalance (uint64)
// [ 88]      slashed (bool)
// [ 89- 96]  activationEligibilityEpoch (uint64)
// [ 97-104]  activationEpoch (uint64)
// [105-112]  exitEpoch (uint64)
// [113-120]  withdrawableEpoch (uint64)
// Total size: 121 bytes
type Validator []byte

// NewValidator creates a new Validator with the specified size
func NewValidator() Validator {
	return make([]byte, 121)
}

// NewValidatorWithValues creates a new Validator with the provided values
// Parameters:
//   - pubkey: bytevector[48] value
//   - withdrawalCredentials: bytevector[32] value
//   - effectiveBalance: uint64 value
//   - slashed: boolean value
//   - activationEligibilityEpoch: uint64 value
//   - activationEpoch: uint64 value
//   - exitEpoch: uint64 value
//   - withdrawableEpoch: uint64 value
func NewValidatorWithValues(pubkey [48]byte, withdrawalCredentials [32]byte, effectiveBalance uint64, slashed bool, activationEligibilityEpoch uint64, activationEpoch uint64, exitEpoch uint64, withdrawableEpoch uint64) Validator {
	obj := NewValidator()
	obj.SetPubkey(pubkey)
	obj.SetWithdrawalCredentials(withdrawalCredentials)
	obj.SetEffectiveBalance(effectiveBalance)
	obj.SetSlashed(slashed)
	obj.SetActivationEligibilityEpoch(activationEligibilityEpoch)
	obj.SetActivationEpoch(activationEpoch)
	obj.SetExitEpoch(exitEpoch)
	obj.SetWithdrawableEpoch(withdrawableEpoch)
	return obj
}

// Fixed returns true if the type is fixed size
func (s Validator) Fixed() bool {
	return true
}

// SizeSSZ returns the size of the serialized object
func (s Validator) SizeSSZ() int {
	return 121
}

// MarshalSSZ returns the bytes
func (s Validator) MarshalSSZ() ([]byte, error) {
	// Check that the length matches the expected size
	if len(s) != s.SizeSSZ() {
		return nil, ssz.NewErrSizeMismatch(s.SizeSSZ(), len(s))
	}
	return s, nil
}

// FillHashBuffer fills the provided buffer with hashes of all fields
func (s Validator) FillHashBuffer(buf []byte) error {
	// Ensure buffer is large enough
	if len(buf) < 256 {
		return fmt.Errorf("buffer too small: need %d bytes, got %d", 256, len(buf))
	}

	// Hash each field and store in buffer
	// Field pubkey (bytevector, size 48)
	{
		fieldData := s[0:48]
		root, err := merkle_tree.BytesRoot(fieldData)
		if err != nil {
			return err
		}
		copy(buf[0:32], root[:])
	}

	// Field withdrawalCredentials (bytevector, size 32)
	copy(buf[32:64], s[48:80])

	// Field effectiveBalance (uint64)
	copy(buf[64:72], s[80:88])
	for j := 72; j < 96; j++ {
		buf[j] = 0
	}

	// Field slashed (bool)
	buf[96] = s[88]
	for j := 97; j < 128; j++ {
		buf[j] = 0
	}

	// Field activationEligibilityEpoch (uint64)
	copy(buf[128:136], s[89:97])
	for j := 136; j < 160; j++ {
		buf[j] = 0
	}

	// Field activationEpoch (uint64)
	copy(buf[160:168], s[97:105])
	for j := 168; j < 192; j++ {
		buf[j] = 0
	}

	// Field exitEpoch (uint64)
	copy(buf[192:200], s[105:113])
	for j := 200; j < 224; j++ {
		buf[j] = 0
	}

	// Field withdrawableEpoch (uint64)
	copy(buf[224:232], s[113:121])
	for j := 232; j < 256; j++ {
		buf[j] = 0
	}

	return nil
}

// HashSSZTo writes the merkle tree hash of the object to the provided buffer
func (s Validator) HashSSZTo(buf []byte) ([]byte, error) {
	// Ensure buffer has at least 32 bytes
	if len(buf) < 32 {
		return nil, fmt.Errorf("buffer too small: need at least 32 bytes, got %d", len(buf))
	}
	// Get hash buffer from pool
	numFields := 8
	poolBuf := bufpool.Get(numFields * 32)
	defer bufpool.Put(poolBuf)
	hashBuffer := poolBuf.B[:numFields*32]
	// Fill the hash buffer with field hashes
	if err := s.FillHashBuffer(hashBuffer); err != nil {
		return nil, err
	}
	// Compute merkle root from the field hashes
	if err := merkle_tree.ComputeMerkleRoot(hashBuffer, hashBuffer); err != nil {
		return nil, err
	}
	// Copy the root hash to the provided buffer
	copy(buf, hashBuffer[:32])
	return buf[:32], nil
}

// HashSSZ returns the merkle tree hash of the object
func (s Validator) HashSSZ() (hash [32]byte, err error) {
	_, err = s.HashSSZTo(hash[:])
	return
}

// Pubkey returns the pubkey field
// Bytes: 0-47
func (s Validator) Pubkey() [48]byte {
	return [48]byte(s[0:48])
}

// WithdrawalCredentials returns the withdrawalCredentials field
// Bytes: 48-79
func (s Validator) WithdrawalCredentials() [32]byte {
	return [32]byte(s[48:80])
}

// EffectiveBalance returns the effectiveBalance field
// Bytes: 80-87
func (s Validator) EffectiveBalance() uint64 {
	return binary.LittleEndian.Uint64(s[80:88])
}

// Slashed returns the slashed field
// Byte: 88
func (s Validator) Slashed() bool {
	return s[88] != 0
}

// ActivationEligibilityEpoch returns the activationEligibilityEpoch field
// Bytes: 89-96
func (s Validator) ActivationEligibilityEpoch() uint64 {
	return binary.LittleEndian.Uint64(s[89:97])
}

// ActivationEpoch returns the activationEpoch field
// Bytes: 97-104
func (s Validator) ActivationEpoch() uint64 {
	return binary.LittleEndian.Uint64(s[97:105])
}

// ExitEpoch returns the exitEpoch field
// Bytes: 105-112
func (s Validator) ExitEpoch() uint64 {
	return binary.LittleEndian.Uint64(s[105:113])
}

// WithdrawableEpoch returns the withdrawableEpoch field
// Bytes: 113-120
func (s Validator) WithdrawableEpoch() uint64 {
	return binary.LittleEndian.Uint64(s[113:121])
}

// SetPubkey sets the pubkey field
// Bytes: 0-47
func (s Validator) SetPubkey(v [48]byte) {
	copy(s[0:48], v[:])
}

// SetWithdrawalCredentials sets the withdrawalCredentials field
// Bytes: 48-79
func (s Validator) SetWithdrawalCredentials(v [32]byte) {
	copy(s[48:80], v[:])
}

// SetEffectiveBalance sets the effectiveBalance field
// Bytes: 80-87
func (s Validator) SetEffectiveBalance(v uint64) {
	binary.LittleEndian.PutUint64(s[80:88], v)
}

// SetSlashed sets the slashed field
// Byte: 88
func (s Validator) SetSlashed(v bool) {
	if v {
		s[88] = 1
	} else {
		s[88] = 0
	}
}

// SetActivationEligibilityEpoch sets the activationEligibilityEpoch field
// Bytes: 89-96
func (s Validator) SetActivationEligibilityEpoch(v uint64) {
	binary.LittleEndian.PutUint64(s[89:97], v)
}

// SetActivationEpoch sets the activationEpoch field
// Bytes: 97-104
func (s Validator) SetActivationEpoch(v uint64) {
	binary.LittleEndian.PutUint64(s[97:105], v)
}

// SetExitEpoch sets the exitEpoch field
// Bytes: 105-112
func (s Validator) SetExitEpoch(v uint64) {
	binary.LittleEndian.PutUint64(s[105:113], v)
}

// SetWithdrawableEpoch sets the withdrawableEpoch field
// Bytes: 113-120
func (s Validator) SetWithdrawableEpoch(v uint64) {
	binary.LittleEndian.PutUint64(s[113:121], v)
}

// BeaconBlockHeader is a fixed-size SSZ container with the following byte layout:
//
// Byte layout:
// [  0-  7]  slot (uint64)
// [  8- 15]  proposerIndex (uint64)
// [ 16- 47]  parentRoot (bytevector[32])
// [ 48- 79]  stateRoot (bytevector[32])
// [ 80-111]  bodyRoot (bytevector[32])
// Total size: 112 bytes
type BeaconBlockHeader []byte

// NewBeaconBlockHeader creates a new BeaconBlockHeader with the specified size
func NewBeaconBlockHeader() BeaconBlockHeader {
	return make([]byte, 112)
}

// NewBeaconBlockHeaderWithValues creates a new BeaconBlockHeader with the provided values
// Parameters:
//   - slot: uint64 value
//   - proposerIndex: uint64 value
//   - parentRoot: bytevector[32] value
//   - stateRoot: bytevector[32] value
//   - bodyRoot: bytevector[32] value
func NewBeaconBlockHeaderWithValues(slot uint64, proposerIndex uint64, parentRoot [32]byte, stateRoot [32]byte, bodyRoot [32]byte) BeaconBlockHeader {
	obj := NewBeaconBlockHeader()
	obj.SetSlot(slot)
	obj.SetProposerIndex(proposerIndex)
	obj.SetParentRoot(parentRoot)
	obj.SetStateRoot(stateRoot)
	obj.SetBodyRoot(bodyRoot)
	return obj
}

// Fixed returns true if the type is fixed size
func (s BeaconBlockHeader) Fixed() bool {
	return true
}

// SizeSSZ returns the size of the serialized object
func (s BeaconBlockHeader) SizeSSZ() int {
	return 112
}

// MarshalSSZ returns the bytes
func (s BeaconBlockHeader) MarshalSSZ() ([]byte, error) {
	// Check that the length matches the expected size
	if len(s) != s.SizeSSZ() {
		return nil, ssz.NewErrSizeMismatch(s.SizeSSZ(), len(s))
	}
	return s, nil
}

// FillHashBuffer fills the provided buffer with hashes of all fields
func (s BeaconBlockHeader) FillHashBuffer(buf []byte) error {
	// Ensure buffer is large enough
	if len(buf) < 160 {
		return fmt.Errorf("buffer too small: need %d bytes, got %d", 160, len(buf))
	}

	// Hash each field and store in buffer
	// Field slot (uint64)
	copy(buf[0:8], s[0:8])
	for j := 8; j < 32; j++ {
		buf[j] = 0
	}

	// Field proposerIndex (uint64)
	copy(buf[32:40], s[8:16])
	for j := 40; j < 64; j++ {
		buf[j] = 0
	}

	// Field parentRoot (bytevector, size 32)
	copy(buf[64:96], s[16:48])

	// Field stateRoot (bytevector, size 32)
	copy(buf[96:128], s[48:80])

	// Field bodyRoot (bytevector, size 32)
	copy(buf[128:160], s[80:112])

	return nil
}

// HashSSZTo writes the merkle tree hash of the object to the provided buffer
func (s BeaconBlockHeader) HashSSZTo(buf []byte) ([]byte, error) {
	// Ensure buffer has at least 32 bytes
	if len(buf) < 32 {
		return nil, fmt.Errorf("buffer too small: need at least 32 bytes, got %d", len(buf))
	}
	// Get hash buffer from pool
	numFields := 5
	poolBuf := bufpool.Get(numFields * 32)
	defer bufpool.Put(poolBuf)
	hashBuffer := poolBuf.B[:numFields*32]
	// Fill the hash buffer with field hashes
	if err := s.FillHashBuffer(hashBuffer); err != nil {
		return nil, err
	}
	// Compute merkle root from the field hashes
	if err := merkle_tree.ComputeMerkleRoot(hashBuffer, hashBuffer); err != nil {
		return nil, err
	}
	// Copy the root hash to the provided buffer
	copy(buf, hashBuffer[:32])
	return buf[:32], nil
}

// HashSSZ returns the merkle tree hash of the object
func (s BeaconBlockHeader) HashSSZ() (hash [32]byte, err error) {
	_, err = s.HashSSZTo(hash[:])
	return
}

// Slot returns the slot field
// Bytes: 0-7
func (s BeaconBlockHeader) Slot() uint64 {
	return binary.LittleEndian.Uint64(s[0:8])
}

// ProposerIndex returns the proposerIndex field
// Bytes: 8-15
func (s BeaconBlockHeader) ProposerIndex() uint64 {
	return binary.LittleEndian.Uint64(s[8:16])
}

// ParentRoot returns the parentRoot field
// Bytes: 16-47
func (s BeaconBlockHeader) ParentRoot() [32]byte {
	return [32]byte(s[16:48])
}

// StateRoot returns the stateRoot field
// Bytes: 48-79
func (s BeaconBlockHeader) StateRoot() [32]byte {
	return [32]byte(s[48:80])
}

// BodyRoot returns the bodyRoot field
// Bytes: 80-111
func (s BeaconBlockHeader) BodyRoot() [32]byte {
	return [32]byte(s[80:112])
}

// SetSlot sets the slot field
// Bytes: 0-7
func (s BeaconBlockHeader) SetSlot(v uint64) {
	binary.LittleEndian.PutUint64(s[0:8], v)
}

// SetProposerIndex sets the proposerIndex field
// Bytes: 8-15
func (s BeaconBlockHeader) SetProposerIndex(v uint64) {
	binary.LittleEndian.PutUint64(s[8:16], v)
}

// SetParentRoot sets the parentRoot field
// Bytes: 16-47
func (s BeaconBlockHeader) SetParentRoot(v [32]byte) {
	copy(s[16:48], v[:])
}

// SetStateRoot sets the stateRoot field
// Bytes: 48-79
func (s BeaconBlockHeader) SetStateRoot(v [32]byte) {
	copy(s[48:80], v[:])
}

// SetBodyRoot sets the bodyRoot field
// Bytes: 80-111
func (s BeaconBlockHeader) SetBodyRoot(v [32]byte) {
	copy(s[80:112], v[:])
}

// SyncCommittee is a fixed-size SSZ container with the following byte layout:
//
// Byte layout:
// [  0-24575]  pubkeys (vector[512])
// [24576-24623]  aggregatePubkey (bytevector[48])
// Total size: 24624 bytes
type SyncCommittee []byte

// NewSyncCommittee creates a new SyncCommittee with the specified size
func NewSyncCommittee() SyncCommittee {
	return make([]byte, 24624)
}

// NewSyncCommitteeWithValues creates a new SyncCommittee with the provided values
// Parameters:
//   - pubkeys: vector value
//   - aggregatePubkey: bytevector[48] value
func NewSyncCommitteeWithValues(pubkeys interface{}, aggregatePubkey [48]byte) SyncCommittee {
	obj := NewSyncCommittee()
	obj.SetPubkeys(pubkeys)
	obj.SetAggregatePubkey(aggregatePubkey)
	return obj
}

// Fixed returns true if the type is fixed size
func (s SyncCommittee) Fixed() bool {
	return true
}

// SizeSSZ returns the size of the serialized object
func (s SyncCommittee) SizeSSZ() int {
	return 24624
}

// MarshalSSZ returns the bytes
func (s SyncCommittee) MarshalSSZ() ([]byte, error) {
	// Check that the length matches the expected size
	if len(s) != s.SizeSSZ() {
		return nil, ssz.NewErrSizeMismatch(s.SizeSSZ(), len(s))
	}
	return s, nil
}

// FillHashBuffer fills the provided buffer with hashes of all fields
func (s SyncCommittee) FillHashBuffer(buf []byte) error {
	// Ensure buffer is large enough
	if len(buf) < 64 {
		return fmt.Errorf("buffer too small: need %d bytes, got %d", 64, len(buf))
	}

	// Hash each field and store in buffer
	// Field pubkeys (vector type not yet supported)
	return fmt.Errorf("vector field type not yet supported: vector")

	// Field aggregatePubkey (bytevector, size 48)
	{
		fieldData := s[24576:24624]
		root, err := merkle_tree.BytesRoot(fieldData)
		if err != nil {
			return err
		}
		copy(buf[32:64], root[:])
	}

	return nil
}

// HashSSZTo writes the merkle tree hash of the object to the provided buffer
func (s SyncCommittee) HashSSZTo(buf []byte) ([]byte, error) {
	// Ensure buffer has at least 32 bytes
	if len(buf) < 32 {
		return nil, fmt.Errorf("buffer too small: need at least 32 bytes, got %d", len(buf))
	}
	// Get hash buffer from pool
	numFields := 2
	poolBuf := bufpool.Get(numFields * 32)
	defer bufpool.Put(poolBuf)
	hashBuffer := poolBuf.B[:numFields*32]
	// Fill the hash buffer with field hashes
	if err := s.FillHashBuffer(hashBuffer); err != nil {
		return nil, err
	}
	// Compute merkle root from the field hashes
	if err := merkle_tree.ComputeMerkleRoot(hashBuffer, hashBuffer); err != nil {
		return nil, err
	}
	// Copy the root hash to the provided buffer
	copy(buf, hashBuffer[:32])
	return buf[:32], nil
}

// HashSSZ returns the merkle tree hash of the object
func (s SyncCommittee) HashSSZ() (hash [32]byte, err error) {
	_, err = s.HashSSZTo(hash[:])
	return
}

// Pubkeys returns the pubkeys field
func (s SyncCommittee) Pubkeys() interface{} {
	return "TODO: implement vector getter"
}

// AggregatePubkey returns the aggregatePubkey field
// Bytes: 24576-24623
func (s SyncCommittee) AggregatePubkey() [48]byte {
	return [48]byte(s[24576:24624])
}

// SetPubkeys sets the pubkeys field
func (s SyncCommittee) SetPubkeys(v interface{}) {
	// TODO: implement vector setter
}

// SetAggregatePubkey sets the aggregatePubkey field
// Bytes: 24576-24623
func (s SyncCommittee) SetAggregatePubkey(v [48]byte) {
	copy(s[24576:24624], v[:])
}

// AttestationData is a fixed-size SSZ container with the following byte layout:
//
// Byte layout:
// [  0-  7]  slot (uint64)
// [  8- 15]  index (uint64)
// [ 16- 47]  beaconBlockRoot (bytevector[32])
// [ 48- 87]  source (ref: Checkpoint)
// [ 88-127]  target (ref: Checkpoint)
// Total size: 128 bytes
type AttestationData []byte

// NewAttestationData creates a new AttestationData with the specified size
func NewAttestationData() AttestationData {
	return make([]byte, 128)
}

// NewAttestationDataWithValues creates a new AttestationData with the provided values
// Parameters:
//   - slot: uint64 value
//   - index: uint64 value
//   - beaconBlockRoot: bytevector[32] value
//   - source: Checkpoint reference
//   - target: Checkpoint reference
func NewAttestationDataWithValues(slot uint64, index uint64, beaconBlockRoot [32]byte, source Checkpoint, target Checkpoint) AttestationData {
	obj := NewAttestationData()
	obj.SetSlot(slot)
	obj.SetIndex(index)
	obj.SetBeaconBlockRoot(beaconBlockRoot)
	obj.SetSource(source)
	obj.SetTarget(target)
	return obj
}

// Fixed returns true if the type is fixed size
func (s AttestationData) Fixed() bool {
	return true
}

// SizeSSZ returns the size of the serialized object
func (s AttestationData) SizeSSZ() int {
	return 128
}

// MarshalSSZ returns the bytes
func (s AttestationData) MarshalSSZ() ([]byte, error) {
	// Check that the length matches the expected size
	if len(s) != s.SizeSSZ() {
		return nil, ssz.NewErrSizeMismatch(s.SizeSSZ(), len(s))
	}
	return s, nil
}

// FillHashBuffer fills the provided buffer with hashes of all fields
func (s AttestationData) FillHashBuffer(buf []byte) error {
	// Ensure buffer is large enough
	if len(buf) < 160 {
		return fmt.Errorf("buffer too small: need %d bytes, got %d", 160, len(buf))
	}

	// Hash each field and store in buffer
	// Field slot (uint64)
	copy(buf[0:8], s[0:8])
	for j := 8; j < 32; j++ {
		buf[j] = 0
	}

	// Field index (uint64)
	copy(buf[32:40], s[8:16])
	for j := 40; j < 64; j++ {
		buf[j] = 0
	}

	// Field beaconBlockRoot (bytevector, size 32)
	copy(buf[64:96], s[16:48])

	// Field source (ref to Checkpoint)
	{
		refData := Checkpoint(s[48:88])
		_, err := refData.HashSSZTo(buf[96:128])
		if err != nil {
			return err
		}
	}

	// Field target (ref to Checkpoint)
	{
		refData := Checkpoint(s[88:128])
		_, err := refData.HashSSZTo(buf[128:160])
		if err != nil {
			return err
		}
	}

	return nil
}

// HashSSZTo writes the merkle tree hash of the object to the provided buffer
func (s AttestationData) HashSSZTo(buf []byte) ([]byte, error) {
	// Ensure buffer has at least 32 bytes
	if len(buf) < 32 {
		return nil, fmt.Errorf("buffer too small: need at least 32 bytes, got %d", len(buf))
	}
	// Get hash buffer from pool
	numFields := 5
	poolBuf := bufpool.Get(numFields * 32)
	defer bufpool.Put(poolBuf)
	hashBuffer := poolBuf.B[:numFields*32]
	// Fill the hash buffer with field hashes
	if err := s.FillHashBuffer(hashBuffer); err != nil {
		return nil, err
	}
	// Compute merkle root from the field hashes
	if err := merkle_tree.ComputeMerkleRoot(hashBuffer, hashBuffer); err != nil {
		return nil, err
	}
	// Copy the root hash to the provided buffer
	copy(buf, hashBuffer[:32])
	return buf[:32], nil
}

// HashSSZ returns the merkle tree hash of the object
func (s AttestationData) HashSSZ() (hash [32]byte, err error) {
	_, err = s.HashSSZTo(hash[:])
	return
}

// Slot returns the slot field
// Bytes: 0-7
func (s AttestationData) Slot() uint64 {
	return binary.LittleEndian.Uint64(s[0:8])
}

// Index returns the index field
// Bytes: 8-15
func (s AttestationData) Index() uint64 {
	return binary.LittleEndian.Uint64(s[8:16])
}

// BeaconBlockRoot returns the beaconBlockRoot field
// Bytes: 16-47
func (s AttestationData) BeaconBlockRoot() [32]byte {
	return [32]byte(s[16:48])
}

// Source returns the source field
// Bytes: 48-87
func (s AttestationData) Source() Checkpoint {
	return Checkpoint(s[48:88])
}

// Target returns the target field
// Bytes: 88-127
func (s AttestationData) Target() Checkpoint {
	return Checkpoint(s[88:128])
}

// SetSlot sets the slot field
// Bytes: 0-7
func (s AttestationData) SetSlot(v uint64) {
	binary.LittleEndian.PutUint64(s[0:8], v)
}

// SetIndex sets the index field
// Bytes: 8-15
func (s AttestationData) SetIndex(v uint64) {
	binary.LittleEndian.PutUint64(s[8:16], v)
}

// SetBeaconBlockRoot sets the beaconBlockRoot field
// Bytes: 16-47
func (s AttestationData) SetBeaconBlockRoot(v [32]byte) {
	copy(s[16:48], v[:])
}

// SetSource sets the source field
// Bytes: 48-87
func (s AttestationData) SetSource(v Checkpoint) {
	copy(s[48:88], v)
}

// SetTarget sets the target field
// Bytes: 88-127
func (s AttestationData) SetTarget(v Checkpoint) {
	copy(s[88:128], v)
}

// SignedBeaconBlockHeader is a fixed-size SSZ container with the following byte layout:
//
// Byte layout:
// [  0-111]  message (ref: BeaconBlockHeader)
// [112-207]  signature (bytevector[96])
// Total size: 208 bytes
type SignedBeaconBlockHeader []byte

// NewSignedBeaconBlockHeader creates a new SignedBeaconBlockHeader with the specified size
func NewSignedBeaconBlockHeader() SignedBeaconBlockHeader {
	return make([]byte, 208)
}

// NewSignedBeaconBlockHeaderWithValues creates a new SignedBeaconBlockHeader with the provided values
// Parameters:
//   - message: BeaconBlockHeader reference
//   - signature: bytevector[96] value
func NewSignedBeaconBlockHeaderWithValues(message BeaconBlockHeader, signature [96]byte) SignedBeaconBlockHeader {
	obj := NewSignedBeaconBlockHeader()
	obj.SetMessage(message)
	obj.SetSignature(signature)
	return obj
}

// Fixed returns true if the type is fixed size
func (s SignedBeaconBlockHeader) Fixed() bool {
	return true
}

// SizeSSZ returns the size of the serialized object
func (s SignedBeaconBlockHeader) SizeSSZ() int {
	return 208
}

// MarshalSSZ returns the bytes
func (s SignedBeaconBlockHeader) MarshalSSZ() ([]byte, error) {
	// Check that the length matches the expected size
	if len(s) != s.SizeSSZ() {
		return nil, ssz.NewErrSizeMismatch(s.SizeSSZ(), len(s))
	}
	return s, nil
}

// FillHashBuffer fills the provided buffer with hashes of all fields
func (s SignedBeaconBlockHeader) FillHashBuffer(buf []byte) error {
	// Ensure buffer is large enough
	if len(buf) < 64 {
		return fmt.Errorf("buffer too small: need %d bytes, got %d", 64, len(buf))
	}

	// Hash each field and store in buffer
	// Field message (ref to BeaconBlockHeader)
	{
		refData := BeaconBlockHeader(s[0:112])
		_, err := refData.HashSSZTo(buf[0:32])
		if err != nil {
			return err
		}
	}

	// Field signature (bytevector, size 96)
	{
		fieldData := s[112:208]
		root, err := merkle_tree.BytesRoot(fieldData)
		if err != nil {
			return err
		}
		copy(buf[32:64], root[:])
	}

	return nil
}

// HashSSZTo writes the merkle tree hash of the object to the provided buffer
func (s SignedBeaconBlockHeader) HashSSZTo(buf []byte) ([]byte, error) {
	// Ensure buffer has at least 32 bytes
	if len(buf) < 32 {
		return nil, fmt.Errorf("buffer too small: need at least 32 bytes, got %d", len(buf))
	}
	// Get hash buffer from pool
	numFields := 2
	poolBuf := bufpool.Get(numFields * 32)
	defer bufpool.Put(poolBuf)
	hashBuffer := poolBuf.B[:numFields*32]
	// Fill the hash buffer with field hashes
	if err := s.FillHashBuffer(hashBuffer); err != nil {
		return nil, err
	}
	// Compute merkle root from the field hashes
	if err := merkle_tree.ComputeMerkleRoot(hashBuffer, hashBuffer); err != nil {
		return nil, err
	}
	// Copy the root hash to the provided buffer
	copy(buf, hashBuffer[:32])
	return buf[:32], nil
}

// HashSSZ returns the merkle tree hash of the object
func (s SignedBeaconBlockHeader) HashSSZ() (hash [32]byte, err error) {
	_, err = s.HashSSZTo(hash[:])
	return
}

// Message returns the message field
// Bytes: 0-111
func (s SignedBeaconBlockHeader) Message() BeaconBlockHeader {
	return BeaconBlockHeader(s[0:112])
}

// Signature returns the signature field
// Bytes: 112-207
func (s SignedBeaconBlockHeader) Signature() [96]byte {
	return [96]byte(s[112:208])
}

// SetMessage sets the message field
// Bytes: 0-111
func (s SignedBeaconBlockHeader) SetMessage(v BeaconBlockHeader) {
	copy(s[0:112], v)
}

// SetSignature sets the signature field
// Bytes: 112-207
func (s SignedBeaconBlockHeader) SetSignature(v [96]byte) {
	copy(s[112:208], v[:])
}

// ProposerSlashing is a fixed-size SSZ container with the following byte layout:
//
// Byte layout:
// [  0-207]  signedHeader1 (ref: SignedBeaconBlockHeader)
// [208-415]  signedHeader2 (ref: SignedBeaconBlockHeader)
// Total size: 416 bytes
type ProposerSlashing []byte

// NewProposerSlashing creates a new ProposerSlashing with the specified size
func NewProposerSlashing() ProposerSlashing {
	return make([]byte, 416)
}

// NewProposerSlashingWithValues creates a new ProposerSlashing with the provided values
// Parameters:
//   - signedHeader1: SignedBeaconBlockHeader reference
//   - signedHeader2: SignedBeaconBlockHeader reference
func NewProposerSlashingWithValues(signedHeader1 SignedBeaconBlockHeader, signedHeader2 SignedBeaconBlockHeader) ProposerSlashing {
	obj := NewProposerSlashing()
	obj.SetSignedHeader1(signedHeader1)
	obj.SetSignedHeader2(signedHeader2)
	return obj
}

// Fixed returns true if the type is fixed size
func (s ProposerSlashing) Fixed() bool {
	return true
}

// SizeSSZ returns the size of the serialized object
func (s ProposerSlashing) SizeSSZ() int {
	return 416
}

// MarshalSSZ returns the bytes
func (s ProposerSlashing) MarshalSSZ() ([]byte, error) {
	// Check that the length matches the expected size
	if len(s) != s.SizeSSZ() {
		return nil, ssz.NewErrSizeMismatch(s.SizeSSZ(), len(s))
	}
	return s, nil
}

// FillHashBuffer fills the provided buffer with hashes of all fields
func (s ProposerSlashing) FillHashBuffer(buf []byte) error {
	// Ensure buffer is large enough
	if len(buf) < 64 {
		return fmt.Errorf("buffer too small: need %d bytes, got %d", 64, len(buf))
	}

	// Hash each field and store in buffer
	// Field signedHeader1 (ref to SignedBeaconBlockHeader)
	{
		refData := SignedBeaconBlockHeader(s[0:208])
		_, err := refData.HashSSZTo(buf[0:32])
		if err != nil {
			return err
		}
	}

	// Field signedHeader2 (ref to SignedBeaconBlockHeader)
	{
		refData := SignedBeaconBlockHeader(s[208:416])
		_, err := refData.HashSSZTo(buf[32:64])
		if err != nil {
			return err
		}
	}

	return nil
}

// HashSSZTo writes the merkle tree hash of the object to the provided buffer
func (s ProposerSlashing) HashSSZTo(buf []byte) ([]byte, error) {
	// Ensure buffer has at least 32 bytes
	if len(buf) < 32 {
		return nil, fmt.Errorf("buffer too small: need at least 32 bytes, got %d", len(buf))
	}
	// Get hash buffer from pool
	numFields := 2
	poolBuf := bufpool.Get(numFields * 32)
	defer bufpool.Put(poolBuf)
	hashBuffer := poolBuf.B[:numFields*32]
	// Fill the hash buffer with field hashes
	if err := s.FillHashBuffer(hashBuffer); err != nil {
		return nil, err
	}
	// Compute merkle root from the field hashes
	if err := merkle_tree.ComputeMerkleRoot(hashBuffer, hashBuffer); err != nil {
		return nil, err
	}
	// Copy the root hash to the provided buffer
	copy(buf, hashBuffer[:32])
	return buf[:32], nil
}

// HashSSZ returns the merkle tree hash of the object
func (s ProposerSlashing) HashSSZ() (hash [32]byte, err error) {
	_, err = s.HashSSZTo(hash[:])
	return
}

// SignedHeader1 returns the signedHeader1 field
// Bytes: 0-207
func (s ProposerSlashing) SignedHeader1() SignedBeaconBlockHeader {
	return SignedBeaconBlockHeader(s[0:208])
}

// SignedHeader2 returns the signedHeader2 field
// Bytes: 208-415
func (s ProposerSlashing) SignedHeader2() SignedBeaconBlockHeader {
	return SignedBeaconBlockHeader(s[208:416])
}

// SetSignedHeader1 sets the signedHeader1 field
// Bytes: 0-207
func (s ProposerSlashing) SetSignedHeader1(v SignedBeaconBlockHeader) {
	copy(s[0:208], v)
}

// SetSignedHeader2 sets the signedHeader2 field
// Bytes: 208-415
func (s ProposerSlashing) SetSignedHeader2(v SignedBeaconBlockHeader) {
	copy(s[208:416], v)
}

// DepositData is a fixed-size SSZ container with the following byte layout:
//
// Byte layout:
// [  0- 47]  pubkey (bytevector[48])
// [ 48- 79]  withdrawalCredentials (bytevector[32])
// [ 80- 87]  amount (uint64)
// [ 88-183]  signature (bytevector[96])
// Total size: 184 bytes
type DepositData []byte

// NewDepositData creates a new DepositData with the specified size
func NewDepositData() DepositData {
	return make([]byte, 184)
}

// NewDepositDataWithValues creates a new DepositData with the provided values
// Parameters:
//   - pubkey: bytevector[48] value
//   - withdrawalCredentials: bytevector[32] value
//   - amount: uint64 value
//   - signature: bytevector[96] value
func NewDepositDataWithValues(pubkey [48]byte, withdrawalCredentials [32]byte, amount uint64, signature [96]byte) DepositData {
	obj := NewDepositData()
	obj.SetPubkey(pubkey)
	obj.SetWithdrawalCredentials(withdrawalCredentials)
	obj.SetAmount(amount)
	obj.SetSignature(signature)
	return obj
}

// Fixed returns true if the type is fixed size
func (s DepositData) Fixed() bool {
	return true
}

// SizeSSZ returns the size of the serialized object
func (s DepositData) SizeSSZ() int {
	return 184
}

// MarshalSSZ returns the bytes
func (s DepositData) MarshalSSZ() ([]byte, error) {
	// Check that the length matches the expected size
	if len(s) != s.SizeSSZ() {
		return nil, ssz.NewErrSizeMismatch(s.SizeSSZ(), len(s))
	}
	return s, nil
}

// FillHashBuffer fills the provided buffer with hashes of all fields
func (s DepositData) FillHashBuffer(buf []byte) error {
	// Ensure buffer is large enough
	if len(buf) < 128 {
		return fmt.Errorf("buffer too small: need %d bytes, got %d", 128, len(buf))
	}

	// Hash each field and store in buffer
	// Field pubkey (bytevector, size 48)
	{
		fieldData := s[0:48]
		root, err := merkle_tree.BytesRoot(fieldData)
		if err != nil {
			return err
		}
		copy(buf[0:32], root[:])
	}

	// Field withdrawalCredentials (bytevector, size 32)
	copy(buf[32:64], s[48:80])

	// Field amount (uint64)
	copy(buf[64:72], s[80:88])
	for j := 72; j < 96; j++ {
		buf[j] = 0
	}

	// Field signature (bytevector, size 96)
	{
		fieldData := s[88:184]
		root, err := merkle_tree.BytesRoot(fieldData)
		if err != nil {
			return err
		}
		copy(buf[96:128], root[:])
	}

	return nil
}

// HashSSZTo writes the merkle tree hash of the object to the provided buffer
func (s DepositData) HashSSZTo(buf []byte) ([]byte, error) {
	// Ensure buffer has at least 32 bytes
	if len(buf) < 32 {
		return nil, fmt.Errorf("buffer too small: need at least 32 bytes, got %d", len(buf))
	}
	// Get hash buffer from pool
	numFields := 4
	poolBuf := bufpool.Get(numFields * 32)
	defer bufpool.Put(poolBuf)
	hashBuffer := poolBuf.B[:numFields*32]
	// Fill the hash buffer with field hashes
	if err := s.FillHashBuffer(hashBuffer); err != nil {
		return nil, err
	}
	// Compute merkle root from the field hashes
	if err := merkle_tree.ComputeMerkleRoot(hashBuffer, hashBuffer); err != nil {
		return nil, err
	}
	// Copy the root hash to the provided buffer
	copy(buf, hashBuffer[:32])
	return buf[:32], nil
}

// HashSSZ returns the merkle tree hash of the object
func (s DepositData) HashSSZ() (hash [32]byte, err error) {
	_, err = s.HashSSZTo(hash[:])
	return
}

// Pubkey returns the pubkey field
// Bytes: 0-47
func (s DepositData) Pubkey() [48]byte {
	return [48]byte(s[0:48])
}

// WithdrawalCredentials returns the withdrawalCredentials field
// Bytes: 48-79
func (s DepositData) WithdrawalCredentials() [32]byte {
	return [32]byte(s[48:80])
}

// Amount returns the amount field
// Bytes: 80-87
func (s DepositData) Amount() uint64 {
	return binary.LittleEndian.Uint64(s[80:88])
}

// Signature returns the signature field
// Bytes: 88-183
func (s DepositData) Signature() [96]byte {
	return [96]byte(s[88:184])
}

// SetPubkey sets the pubkey field
// Bytes: 0-47
func (s DepositData) SetPubkey(v [48]byte) {
	copy(s[0:48], v[:])
}

// SetWithdrawalCredentials sets the withdrawalCredentials field
// Bytes: 48-79
func (s DepositData) SetWithdrawalCredentials(v [32]byte) {
	copy(s[48:80], v[:])
}

// SetAmount sets the amount field
// Bytes: 80-87
func (s DepositData) SetAmount(v uint64) {
	binary.LittleEndian.PutUint64(s[80:88], v)
}

// SetSignature sets the signature field
// Bytes: 88-183
func (s DepositData) SetSignature(v [96]byte) {
	copy(s[88:184], v[:])
}

// Deposit is a fixed-size SSZ container with the following byte layout:
//
// Byte layout:
// [  0-1055]  proof (vector[33])
// [1056-1239]  data (ref: DepositData)
// Total size: 1240 bytes
type Deposit []byte

// NewDeposit creates a new Deposit with the specified size
func NewDeposit() Deposit {
	return make([]byte, 1240)
}

// NewDepositWithValues creates a new Deposit with the provided values
// Parameters:
//   - proof: vector value
//   - data: DepositData reference
func NewDepositWithValues(proof interface{}, data DepositData) Deposit {
	obj := NewDeposit()
	obj.SetProof(proof)
	obj.SetData(data)
	return obj
}

// Fixed returns true if the type is fixed size
func (s Deposit) Fixed() bool {
	return true
}

// SizeSSZ returns the size of the serialized object
func (s Deposit) SizeSSZ() int {
	return 1240
}

// MarshalSSZ returns the bytes
func (s Deposit) MarshalSSZ() ([]byte, error) {
	// Check that the length matches the expected size
	if len(s) != s.SizeSSZ() {
		return nil, ssz.NewErrSizeMismatch(s.SizeSSZ(), len(s))
	}
	return s, nil
}

// FillHashBuffer fills the provided buffer with hashes of all fields
func (s Deposit) FillHashBuffer(buf []byte) error {
	// Ensure buffer is large enough
	if len(buf) < 64 {
		return fmt.Errorf("buffer too small: need %d bytes, got %d", 64, len(buf))
	}

	// Hash each field and store in buffer
	// Field proof (vector type not yet supported)
	return fmt.Errorf("vector field type not yet supported: vector")

	// Field data (ref to DepositData)
	{
		refData := DepositData(s[1056:1240])
		_, err := refData.HashSSZTo(buf[32:64])
		if err != nil {
			return err
		}
	}

	return nil
}

// HashSSZTo writes the merkle tree hash of the object to the provided buffer
func (s Deposit) HashSSZTo(buf []byte) ([]byte, error) {
	// Ensure buffer has at least 32 bytes
	if len(buf) < 32 {
		return nil, fmt.Errorf("buffer too small: need at least 32 bytes, got %d", len(buf))
	}
	// Get hash buffer from pool
	numFields := 2
	poolBuf := bufpool.Get(numFields * 32)
	defer bufpool.Put(poolBuf)
	hashBuffer := poolBuf.B[:numFields*32]
	// Fill the hash buffer with field hashes
	if err := s.FillHashBuffer(hashBuffer); err != nil {
		return nil, err
	}
	// Compute merkle root from the field hashes
	if err := merkle_tree.ComputeMerkleRoot(hashBuffer, hashBuffer); err != nil {
		return nil, err
	}
	// Copy the root hash to the provided buffer
	copy(buf, hashBuffer[:32])
	return buf[:32], nil
}

// HashSSZ returns the merkle tree hash of the object
func (s Deposit) HashSSZ() (hash [32]byte, err error) {
	_, err = s.HashSSZTo(hash[:])
	return
}

// Proof returns the proof field
func (s Deposit) Proof() interface{} {
	return "TODO: implement vector getter"
}

// Data returns the data field
// Bytes: 1056-1239
func (s Deposit) Data() DepositData {
	return DepositData(s[1056:1240])
}

// SetProof sets the proof field
func (s Deposit) SetProof(v interface{}) {
	// TODO: implement vector setter
}

// SetData sets the data field
// Bytes: 1056-1239
func (s Deposit) SetData(v DepositData) {
	copy(s[1056:1240], v)
}

// VoluntaryExit is a fixed-size SSZ container with the following byte layout:
//
// Byte layout:
// [  0-  7]  epoch (uint64)
// [  8- 15]  validatorIndex (uint64)
// Total size: 16 bytes
type VoluntaryExit []byte

// NewVoluntaryExit creates a new VoluntaryExit with the specified size
func NewVoluntaryExit() VoluntaryExit {
	return make([]byte, 16)
}

// NewVoluntaryExitWithValues creates a new VoluntaryExit with the provided values
// Parameters:
//   - epoch: uint64 value
//   - validatorIndex: uint64 value
func NewVoluntaryExitWithValues(epoch uint64, validatorIndex uint64) VoluntaryExit {
	obj := NewVoluntaryExit()
	obj.SetEpoch(epoch)
	obj.SetValidatorIndex(validatorIndex)
	return obj
}

// Fixed returns true if the type is fixed size
func (s VoluntaryExit) Fixed() bool {
	return true
}

// SizeSSZ returns the size of the serialized object
func (s VoluntaryExit) SizeSSZ() int {
	return 16
}

// MarshalSSZ returns the bytes
func (s VoluntaryExit) MarshalSSZ() ([]byte, error) {
	// Check that the length matches the expected size
	if len(s) != s.SizeSSZ() {
		return nil, ssz.NewErrSizeMismatch(s.SizeSSZ(), len(s))
	}
	return s, nil
}

// FillHashBuffer fills the provided buffer with hashes of all fields
func (s VoluntaryExit) FillHashBuffer(buf []byte) error {
	// Ensure buffer is large enough
	if len(buf) < 64 {
		return fmt.Errorf("buffer too small: need %d bytes, got %d", 64, len(buf))
	}

	// Hash each field and store in buffer
	// Field epoch (uint64)
	copy(buf[0:8], s[0:8])
	for j := 8; j < 32; j++ {
		buf[j] = 0
	}

	// Field validatorIndex (uint64)
	copy(buf[32:40], s[8:16])
	for j := 40; j < 64; j++ {
		buf[j] = 0
	}

	return nil
}

// HashSSZTo writes the merkle tree hash of the object to the provided buffer
func (s VoluntaryExit) HashSSZTo(buf []byte) ([]byte, error) {
	// Ensure buffer has at least 32 bytes
	if len(buf) < 32 {
		return nil, fmt.Errorf("buffer too small: need at least 32 bytes, got %d", len(buf))
	}
	// Get hash buffer from pool
	numFields := 2
	poolBuf := bufpool.Get(numFields * 32)
	defer bufpool.Put(poolBuf)
	hashBuffer := poolBuf.B[:numFields*32]
	// Fill the hash buffer with field hashes
	if err := s.FillHashBuffer(hashBuffer); err != nil {
		return nil, err
	}
	// Compute merkle root from the field hashes
	if err := merkle_tree.ComputeMerkleRoot(hashBuffer, hashBuffer); err != nil {
		return nil, err
	}
	// Copy the root hash to the provided buffer
	copy(buf, hashBuffer[:32])
	return buf[:32], nil
}

// HashSSZ returns the merkle tree hash of the object
func (s VoluntaryExit) HashSSZ() (hash [32]byte, err error) {
	_, err = s.HashSSZTo(hash[:])
	return
}

// Epoch returns the epoch field
// Bytes: 0-7
func (s VoluntaryExit) Epoch() uint64 {
	return binary.LittleEndian.Uint64(s[0:8])
}

// ValidatorIndex returns the validatorIndex field
// Bytes: 8-15
func (s VoluntaryExit) ValidatorIndex() uint64 {
	return binary.LittleEndian.Uint64(s[8:16])
}

// SetEpoch sets the epoch field
// Bytes: 0-7
func (s VoluntaryExit) SetEpoch(v uint64) {
	binary.LittleEndian.PutUint64(s[0:8], v)
}

// SetValidatorIndex sets the validatorIndex field
// Bytes: 8-15
func (s VoluntaryExit) SetValidatorIndex(v uint64) {
	binary.LittleEndian.PutUint64(s[8:16], v)
}

// SignedVoluntaryExit is a fixed-size SSZ container with the following byte layout:
//
// Byte layout:
// [  0- 15]  message (ref: VoluntaryExit)
// [ 16-111]  signature (bytevector[96])
// Total size: 112 bytes
type SignedVoluntaryExit []byte

// NewSignedVoluntaryExit creates a new SignedVoluntaryExit with the specified size
func NewSignedVoluntaryExit() SignedVoluntaryExit {
	return make([]byte, 112)
}

// NewSignedVoluntaryExitWithValues creates a new SignedVoluntaryExit with the provided values
// Parameters:
//   - message: VoluntaryExit reference
//   - signature: bytevector[96] value
func NewSignedVoluntaryExitWithValues(message VoluntaryExit, signature [96]byte) SignedVoluntaryExit {
	obj := NewSignedVoluntaryExit()
	obj.SetMessage(message)
	obj.SetSignature(signature)
	return obj
}

// Fixed returns true if the type is fixed size
func (s SignedVoluntaryExit) Fixed() bool {
	return true
}

// SizeSSZ returns the size of the serialized object
func (s SignedVoluntaryExit) SizeSSZ() int {
	return 112
}

// MarshalSSZ returns the bytes
func (s SignedVoluntaryExit) MarshalSSZ() ([]byte, error) {
	// Check that the length matches the expected size
	if len(s) != s.SizeSSZ() {
		return nil, ssz.NewErrSizeMismatch(s.SizeSSZ(), len(s))
	}
	return s, nil
}

// FillHashBuffer fills the provided buffer with hashes of all fields
func (s SignedVoluntaryExit) FillHashBuffer(buf []byte) error {
	// Ensure buffer is large enough
	if len(buf) < 64 {
		return fmt.Errorf("buffer too small: need %d bytes, got %d", 64, len(buf))
	}

	// Hash each field and store in buffer
	// Field message (ref to VoluntaryExit)
	{
		refData := VoluntaryExit(s[0:16])
		_, err := refData.HashSSZTo(buf[0:32])
		if err != nil {
			return err
		}
	}

	// Field signature (bytevector, size 96)
	{
		fieldData := s[16:112]
		root, err := merkle_tree.BytesRoot(fieldData)
		if err != nil {
			return err
		}
		copy(buf[32:64], root[:])
	}

	return nil
}

// HashSSZTo writes the merkle tree hash of the object to the provided buffer
func (s SignedVoluntaryExit) HashSSZTo(buf []byte) ([]byte, error) {
	// Ensure buffer has at least 32 bytes
	if len(buf) < 32 {
		return nil, fmt.Errorf("buffer too small: need at least 32 bytes, got %d", len(buf))
	}
	// Get hash buffer from pool
	numFields := 2
	poolBuf := bufpool.Get(numFields * 32)
	defer bufpool.Put(poolBuf)
	hashBuffer := poolBuf.B[:numFields*32]
	// Fill the hash buffer with field hashes
	if err := s.FillHashBuffer(hashBuffer); err != nil {
		return nil, err
	}
	// Compute merkle root from the field hashes
	if err := merkle_tree.ComputeMerkleRoot(hashBuffer, hashBuffer); err != nil {
		return nil, err
	}
	// Copy the root hash to the provided buffer
	copy(buf, hashBuffer[:32])
	return buf[:32], nil
}

// HashSSZ returns the merkle tree hash of the object
func (s SignedVoluntaryExit) HashSSZ() (hash [32]byte, err error) {
	_, err = s.HashSSZTo(hash[:])
	return
}

// Message returns the message field
// Bytes: 0-15
func (s SignedVoluntaryExit) Message() VoluntaryExit {
	return VoluntaryExit(s[0:16])
}

// Signature returns the signature field
// Bytes: 16-111
func (s SignedVoluntaryExit) Signature() [96]byte {
	return [96]byte(s[16:112])
}

// SetMessage sets the message field
// Bytes: 0-15
func (s SignedVoluntaryExit) SetMessage(v VoluntaryExit) {
	copy(s[0:16], v)
}

// SetSignature sets the signature field
// Bytes: 16-111
func (s SignedVoluntaryExit) SetSignature(v [96]byte) {
	copy(s[16:112], v[:])
}

// SyncAggregate is a fixed-size SSZ container with the following byte layout:
//
// Byte layout:
// [  0- 63]  syncCommitteeBits (bitvector[512])
// [ 64-159]  syncCommitteeSignature (bytevector[96])
// Total size: 160 bytes
type SyncAggregate []byte

// NewSyncAggregate creates a new SyncAggregate with the specified size
func NewSyncAggregate() SyncAggregate {
	return make([]byte, 160)
}

// NewSyncAggregateWithValues creates a new SyncAggregate with the provided values
// Parameters:
//   - syncCommitteeBits: bitvector[512] value (as 64 bytes)
//   - syncCommitteeSignature: bytevector[96] value
func NewSyncAggregateWithValues(syncCommitteeBits [64]byte, syncCommitteeSignature [96]byte) SyncAggregate {
	obj := NewSyncAggregate()
	obj.SetSyncCommitteeBits(syncCommitteeBits)
	obj.SetSyncCommitteeSignature(syncCommitteeSignature)
	return obj
}

// Fixed returns true if the type is fixed size
func (s SyncAggregate) Fixed() bool {
	return true
}

// SizeSSZ returns the size of the serialized object
func (s SyncAggregate) SizeSSZ() int {
	return 160
}

// MarshalSSZ returns the bytes
func (s SyncAggregate) MarshalSSZ() ([]byte, error) {
	// Check that the length matches the expected size
	if len(s) != s.SizeSSZ() {
		return nil, ssz.NewErrSizeMismatch(s.SizeSSZ(), len(s))
	}
	return s, nil
}

// FillHashBuffer fills the provided buffer with hashes of all fields
func (s SyncAggregate) FillHashBuffer(buf []byte) error {
	// Ensure buffer is large enough
	if len(buf) < 64 {
		return fmt.Errorf("buffer too small: need %d bytes, got %d", 64, len(buf))
	}

	// Hash each field and store in buffer
	// Field syncCommitteeBits (bitvector, size 512)
	{
		fieldData := s[0:64]
		root, err := merkle_tree.BytesRoot(fieldData)
		if err != nil {
			return err
		}
		copy(buf[0:32], root[:])
	}

	// Field syncCommitteeSignature (bytevector, size 96)
	{
		fieldData := s[64:160]
		root, err := merkle_tree.BytesRoot(fieldData)
		if err != nil {
			return err
		}
		copy(buf[32:64], root[:])
	}

	return nil
}

// HashSSZTo writes the merkle tree hash of the object to the provided buffer
func (s SyncAggregate) HashSSZTo(buf []byte) ([]byte, error) {
	// Ensure buffer has at least 32 bytes
	if len(buf) < 32 {
		return nil, fmt.Errorf("buffer too small: need at least 32 bytes, got %d", len(buf))
	}
	// Get hash buffer from pool
	numFields := 2
	poolBuf := bufpool.Get(numFields * 32)
	defer bufpool.Put(poolBuf)
	hashBuffer := poolBuf.B[:numFields*32]
	// Fill the hash buffer with field hashes
	if err := s.FillHashBuffer(hashBuffer); err != nil {
		return nil, err
	}
	// Compute merkle root from the field hashes
	if err := merkle_tree.ComputeMerkleRoot(hashBuffer, hashBuffer); err != nil {
		return nil, err
	}
	// Copy the root hash to the provided buffer
	copy(buf, hashBuffer[:32])
	return buf[:32], nil
}

// HashSSZ returns the merkle tree hash of the object
func (s SyncAggregate) HashSSZ() (hash [32]byte, err error) {
	_, err = s.HashSSZTo(hash[:])
	return
}

// SyncCommitteeBits returns the syncCommitteeBits field
// Bytes: 0-63
func (s SyncAggregate) SyncCommitteeBits() [64]byte {
	return [64]byte(s[0:64])
}

// SyncCommitteeSignature returns the syncCommitteeSignature field
// Bytes: 64-159
func (s SyncAggregate) SyncCommitteeSignature() [96]byte {
	return [96]byte(s[64:160])
}

// SetSyncCommitteeBits sets the syncCommitteeBits field
// Bytes: 0-63
func (s SyncAggregate) SetSyncCommitteeBits(v [64]byte) {
	copy(s[0:64], v[:])
}

// SetSyncCommitteeSignature sets the syncCommitteeSignature field
// Bytes: 64-159
func (s SyncAggregate) SetSyncCommitteeSignature(v [96]byte) {
	copy(s[64:160], v[:])
}
