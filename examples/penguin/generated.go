// Code generated by genssz. DO NOT EDIT.

package penguin

import (
	"encoding/binary"
	"fmt"
	"github.com/gfx-labs/ssz"
	"github.com/gfx-labs/ssz/merkle_tree"
)

// Penguin is a fixed-size SSZ container with the following byte layout:
//
// Byte layout:
// [  0- 31]  name (bytevector[32])
// [ 32- 33]  species (bitvector[16])
// [ 34- 35]  awesomness (uint16)
// [ 36]      cuteness (uint8)
// [ 37- 92]  identity (ref: Identity)
// Total size: 93 bytes
type Penguin []byte

// NewPenguin creates a new Penguin with the specified size
func NewPenguin() Penguin {
	return make([]byte, 93)
}

// NewPenguinWithValues creates a new Penguin with the provided values
// Parameters:
//   - name: bytevector[32] value
//   - species: bitvector[16] value (as 2 bytes)
//   - awesomness: uint16 value
//   - cuteness: uint8 value
//   - identity: Identity reference
func NewPenguinWithValues(name [32]byte, species [2]byte, awesomness uint16, cuteness uint8, identity Identity) Penguin {
	obj := NewPenguin()
	obj.SetName(name)
	obj.SetSpecies(species)
	obj.SetAwesomness(awesomness)
	obj.SetCuteness(cuteness)
	obj.SetIdentity(identity)
	return obj
}

// Fixed returns true if the type is fixed size
func (s Penguin) Fixed() bool {
	return true
}

// SizeSSZ returns the size of the serialized object
func (s Penguin) SizeSSZ() int {
	return 93
}

// MarshalSSZ returns the bytes
func (s Penguin) MarshalSSZ() ([]byte, error) {
	// Check that the length matches the expected size
	if len(s) != s.SizeSSZ() {
		return nil, ssz.NewSizeMismatchError(s.SizeSSZ(), len(s))
	}
	return s, nil
}

// FillHashBuffer fills the provided buffer with hashes of all fields
func (s Penguin) FillHashBuffer(buf []byte) error {
	// Ensure buffer is large enough
	if len(buf) < 160 {
		return fmt.Errorf("buffer too small: need %d bytes, got %d", 160, len(buf))
	}

	// Hash each field and store in buffer
	// Field name (bytevector, size 32)
	copy(buf[0:32], s[0:32])

	// Field species (bitvector, size 16)
	copy(buf[32:34], s[32:34])
	for j := 34; j < 64; j++ {
		buf[j] = 0
	}

	// Field awesomness (uint16)
	copy(buf[64:66], s[34:36])
	for j := 66; j < 96; j++ {
		buf[j] = 0
	}

	// Field cuteness (uint8)
	copy(buf[96:97], s[36:37])
	for j := 97; j < 128; j++ {
		buf[j] = 0
	}

	// Field identity (ref to Identity)
	{
		refData := Identity(s[37:93])
		_, err := refData.HashSSZTo(buf[128:160])
		if err != nil {
			return err
		}
	}

	return nil
}

// HashSSZTo writes the merkle tree hash of the object to the provided buffer
func (s Penguin) HashSSZTo(buf []byte) ([]byte, error) {
	// Ensure buffer has at least 32 bytes
	if len(buf) < 32 {
		return nil, fmt.Errorf("buffer too small: need at least 32 bytes, got %d", len(buf))
	}
	// Allocate hash buffer for all fields
	numFields := 5
	hashBuffer := make([]byte, numFields*32)
	// Fill the hash buffer with field hashes
	if err := s.FillHashBuffer(hashBuffer); err != nil {
		return nil, err
	}
	// Compute merkle root from the field hashes
	if err := merkle_tree.ComputeMerkleRoot(hashBuffer, hashBuffer); err != nil {
		return nil, err
	}
	// Copy the root hash to the provided buffer
	copy(buf, hashBuffer[:32])
	return buf[:32], nil
}

// HashSSZ returns the merkle tree hash of the object
func (s Penguin) HashSSZ() (hash [32]byte, err error) {
	_, err = s.HashSSZTo(hash[:])
	return
}

// Name returns the name field
// Bytes: 0-31
func (s Penguin) Name() [32]byte {
	return [32]byte(s[0:32])
}

// Species returns the species field
// Bytes: 32-33
func (s Penguin) Species() [2]byte {
	return [2]byte(s[32:34])
}

// Awesomness returns the awesomness field
// Bytes: 34-35
func (s Penguin) Awesomness() uint16 {
	return binary.LittleEndian.Uint16(s[34:36])
}

// Cuteness returns the cuteness field
// Byte: 36
func (s Penguin) Cuteness() uint8 {
	return s[36]
}

// Identity returns the identity field
// Bytes: 37-92
func (s Penguin) Identity() Identity {
	return Identity(s[37:93])
}

// SetName sets the name field
// Bytes: 0-31
func (s Penguin) SetName(v [32]byte) {
	copy(s[0:32], v[:])
}

// SetSpecies sets the species field
// Bytes: 32-33
func (s Penguin) SetSpecies(v [2]byte) {
	copy(s[32:34], v[:])
}

// SetAwesomness sets the awesomness field
// Bytes: 34-35
func (s Penguin) SetAwesomness(v uint16) {
	binary.LittleEndian.PutUint16(s[34:36], v)
}

// SetCuteness sets the cuteness field
// Byte: 36
func (s Penguin) SetCuteness(v uint8) {
	s[36] = v
}

// SetIdentity sets the identity field
// Bytes: 37-92
func (s Penguin) SetIdentity(v Identity) {
	copy(s[37:93], v)
}

// Identity is a fixed-size SSZ container with the following byte layout:
//
// Byte layout:
// [  0-  7]  id (uint64)
// [  8- 55]  publicKey (bytevector[48])
// Total size: 56 bytes
type Identity []byte

// NewIdentity creates a new Identity with the specified size
func NewIdentity() Identity {
	return make([]byte, 56)
}

// NewIdentityWithValues creates a new Identity with the provided values
// Parameters:
//   - id: uint64 value
//   - publicKey: bytevector[48] value
func NewIdentityWithValues(id uint64, publicKey [48]byte) Identity {
	obj := NewIdentity()
	obj.SetId(id)
	obj.SetPublicKey(publicKey)
	return obj
}

// Fixed returns true if the type is fixed size
func (s Identity) Fixed() bool {
	return true
}

// SizeSSZ returns the size of the serialized object
func (s Identity) SizeSSZ() int {
	return 56
}

// MarshalSSZ returns the bytes
func (s Identity) MarshalSSZ() ([]byte, error) {
	// Check that the length matches the expected size
	if len(s) != s.SizeSSZ() {
		return nil, ssz.NewSizeMismatchError(s.SizeSSZ(), len(s))
	}
	return s, nil
}

// FillHashBuffer fills the provided buffer with hashes of all fields
func (s Identity) FillHashBuffer(buf []byte) error {
	// Ensure buffer is large enough
	if len(buf) < 64 {
		return fmt.Errorf("buffer too small: need %d bytes, got %d", 64, len(buf))
	}

	// Hash each field and store in buffer
	// Field id (uint64)
	copy(buf[0:8], s[0:8])
	for j := 8; j < 32; j++ {
		buf[j] = 0
	}

	// Field publicKey (bytevector, size 48)
	{
		fieldData := s[8:56]
		root, err := merkle_tree.BytesRoot(fieldData)
		if err != nil {
			return err
		}
		copy(buf[32:64], root[:])
	}

	return nil
}

// HashSSZTo writes the merkle tree hash of the object to the provided buffer
func (s Identity) HashSSZTo(buf []byte) ([]byte, error) {
	// Ensure buffer has at least 32 bytes
	if len(buf) < 32 {
		return nil, fmt.Errorf("buffer too small: need at least 32 bytes, got %d", len(buf))
	}
	// Allocate hash buffer for all fields
	numFields := 2
	hashBuffer := make([]byte, numFields*32)
	// Fill the hash buffer with field hashes
	if err := s.FillHashBuffer(hashBuffer); err != nil {
		return nil, err
	}
	// Compute merkle root from the field hashes
	if err := merkle_tree.ComputeMerkleRoot(hashBuffer, hashBuffer); err != nil {
		return nil, err
	}
	// Copy the root hash to the provided buffer
	copy(buf, hashBuffer[:32])
	return buf[:32], nil
}

// HashSSZ returns the merkle tree hash of the object
func (s Identity) HashSSZ() (hash [32]byte, err error) {
	_, err = s.HashSSZTo(hash[:])
	return
}

// Id returns the id field
// Bytes: 0-7
func (s Identity) Id() uint64 {
	return binary.LittleEndian.Uint64(s[0:8])
}

// PublicKey returns the publicKey field
// Bytes: 8-55
func (s Identity) PublicKey() [48]byte {
	return [48]byte(s[8:56])
}

// SetId sets the id field
// Bytes: 0-7
func (s Identity) SetId(v uint64) {
	binary.LittleEndian.PutUint64(s[0:8], v)
}

// SetPublicKey sets the publicKey field
// Bytes: 8-55
func (s Identity) SetPublicKey(v [48]byte) {
	copy(s[8:56], v[:])
}
