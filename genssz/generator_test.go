package genssz

import (
	"bytes"
	"testing"
)

func TestGenerateCode(t *testing.T) {
	// Create a simple schema with fixed-size types
	schemaYAML := []byte(`
package: testpkg
structs:
  - name: Penguin
    type: container
    children:
      - name: name
        type: bytevector
        size: 32
      - name: species
        type: bitvector
        size: 12
      - name: awesomness
        type: uint8
`)

	schema, err := ReadSchemaFromBytes(schemaYAML)
	if err != nil {
		t.Fatalf("Failed to read schema: %v", err)
	}

	world, err := ParseSchemaToWorld(schema)
	if err != nil {
		t.Fatalf("Failed to parse schema to world: %v", err)
	}

	// Generate code
	code, err := GenerateCode(world, schema)
	if err != nil {
		t.Fatalf("Failed to generate code: %v", err)
	}

	// Render the code to check it compiles
	var buf bytes.Buffer
	if err := code.Render(&buf); err != nil {
		t.Fatalf("Failed to render code: %v", err)
	}

	// Check the generated code contains expected elements
	generated := buf.String()

	expectedElements := []string{
		"// Code generated by genssz. DO NOT EDIT.",
		"type Penguin []byte",
		"func NewPenguin() Penguin",
		"func NewPenguinWithValues(name [32]byte, species [2]byte, awesomness uint8) Penguin",
		"func (s Penguin) Fixed() bool",
		"func (s Penguin) SizeSSZ() int",
		"func (s Penguin) Name() [32]byte",
		"func (s Penguin) SetName(v [32]byte)",
		"func (s Penguin) Species() [2]byte",
		"func (s Penguin) SetSpecies(v [2]byte)",
		"func (s Penguin) Awesomness() uint8",
		"func (s Penguin) SetAwesomness(v uint8)",
	}

	for _, expected := range expectedElements {
		if !bytes.Contains([]byte(generated), []byte(expected)) {
			t.Errorf("Generated code missing expected element: %s", expected)
		}
	}

	t.Logf("Generated code:\n%s", generated)
}

func TestGenerateCodeWithRefs(t *testing.T) {
	// Test with references
	schemaYAML := []byte(`
package: testpkg
structs:
  - name: Identity
    type: container
    children:
      - name: id
        type: uint64
      - name: flags
        type: bitvector
        size: 8
  - name: Person
    type: container
    children:
      - name: identity
        type: ref
        ref: Identity
      - name: age
        type: uint16
`)

	schema, err := ReadSchemaFromBytes(schemaYAML)
	if err != nil {
		t.Fatalf("Failed to read schema: %v", err)
	}

	world, err := ParseSchemaToWorld(schema)
	if err != nil {
		t.Fatalf("Failed to parse schema to world: %v", err)
	}

	// Generate code
	code, err := GenerateCode(world, schema)
	if err != nil {
		t.Fatalf("Failed to generate code: %v", err)
	}

	// Render the code
	var buf bytes.Buffer
	if err := code.Render(&buf); err != nil {
		t.Fatalf("Failed to render code: %v", err)
	}

	generated := buf.String()

	// Check both types are generated
	if !bytes.Contains([]byte(generated), []byte("type Identity []byte")) {
		t.Error("Generated code missing Identity type")
	}
	if !bytes.Contains([]byte(generated), []byte("type Person []byte")) {
		t.Error("Generated code missing Person type")
	}

	// Check ref getter/setter
	if !bytes.Contains([]byte(generated), []byte("func (s Person) Identity() Identity")) {
		t.Error("Generated code missing Identity getter with correct return type")
	}
	if !bytes.Contains([]byte(generated), []byte("func (s Person) SetIdentity(v Identity)")) {
		t.Error("Generated code missing Identity setter with correct parameter type")
	}

	t.Logf("Generated code with refs:\n%s", generated)
}
