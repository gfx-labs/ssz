package genssz

import (
	"fmt"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/gfx-labs/ssz"
)

// GenerateCode generates Go code from a World and Schema
func GenerateCode(world *World, schema *Schema) (*jen.File, error) {
	f := jen.NewFile(schema.Package)
	
	// Add generated code comment
	f.HeaderComment("Code generated by genssz. DO NOT EDIT.")
	
	// Add imports
	f.ImportName("github.com/gfx-labs/ssz", "ssz")
	f.ImportName("encoding/binary", "binary")
	f.ImportName("github.com/gfx-labs/ssz/merkle_tree", "merkle_tree")
	f.ImportName("fmt", "fmt")
	
	// Generate code for each type in the world
	for _, structDef := range schema.Structs {
		// Convert to ssz.Field
		sszField := structDef.ToSSZField()
		
		// Only generate for fixed-size types
		isFixed, err := isFixedSize(sszField, schema)
		if err != nil {
			return nil, fmt.Errorf("failed to check if %s is fixed size: %w", structDef.Name, err)
		}
		
		if !isFixed {
			continue // Skip variable-size types
		}
		
		// Generate the type definition with byte layout comment
		if err := generateTypeComment(f, sszField, schema); err != nil {
			return nil, fmt.Errorf("failed to generate type comment for %s: %w", structDef.Name, err)
		}
		f.Type().Id(structDef.Name).Op("[]").Byte()
		f.Line()
		
		// Generate constructor
		if err := generateConstructor(f, sszField, schema); err != nil {
			return nil, fmt.Errorf("failed to generate constructor for %s: %w", structDef.Name, err)
		}
		
		// Generate methods
		if err := generateMethods(f, sszField, schema); err != nil {
			return nil, fmt.Errorf("failed to generate methods for %s: %w", structDef.Name, err)
		}
	}
	
	return f, nil
}

// generateTypeComment generates a detailed comment describing the byte layout
func generateTypeComment(f *jen.File, structDef ssz.Field, schema *Schema) error {
	offsets, totalSize, err := calculateOffsets(structDef, schema)
	if err != nil {
		return err
	}
	
	refs := make(map[string]ssz.Field)
	for _, s := range schema.Structs {
		refs[s.Name] = s.ToSSZField()
	}
	
	// Start with the type description
	f.Comment(fmt.Sprintf("%s is a fixed-size SSZ container with the following byte layout:", structDef.Name))
	f.Comment("")
	f.Comment("Byte layout:")
	
	// Generate layout for each field
	for i, field := range structDef.Children {
		offset := offsets[i]
		size, err := getFieldSize(field, refs)
		if err != nil {
			return err
		}
		
		endOffset := offset + size - 1
		typeDesc := getTypeDescription(field)
		
		if offset == endOffset {
			f.Comment(fmt.Sprintf("[%3d]      %s (%s)", offset, field.Name, typeDesc))
		} else {
			f.Comment(fmt.Sprintf("[%3d-%3d]  %s (%s)", offset, endOffset, field.Name, typeDesc))
		}
	}
	
	f.Comment(fmt.Sprintf("Total size: %d bytes", totalSize))
	
	return nil
}

// getTypeDescription returns a human-readable description of a field type
func getTypeDescription(field ssz.Field) string {
	switch field.Type {
	case ssz.TypeUint8:
		return "uint8"
	case ssz.TypeUint16:
		return "uint16"
	case ssz.TypeUint32:
		return "uint32"
	case ssz.TypeUint64:
		return "uint64"
	case ssz.TypeUint128:
		return "uint128"
	case ssz.TypeUint256:
		return "uint256"
	case ssz.TypeBool:
		return "bool"
	case ssz.TypeBitVector:
		return fmt.Sprintf("bitvector[%d]", field.Size)
	case ssz.TypeVector:
		// Check if this is a vector of uint8 (i.e., bytevector)
		if len(field.Children) > 0 && field.Children[0].Type == ssz.TypeUint8 {
			return fmt.Sprintf("bytevector[%d]", field.Size)
		}
		return fmt.Sprintf("vector[%d]", field.Size)
	case ssz.TypeRef:
		return fmt.Sprintf("ref: %s", field.Ref)
	default:
		return string(field.Type)
	}
}

// isFixedSize checks if a field is fixed size
func isFixedSize(field ssz.Field, schema *Schema) (bool, error) {
	refs := make(map[string]ssz.Field)
	for _, s := range schema.Structs {
		refs[s.Name] = s.ToSSZField()
	}
	
	isVar, err := field.IsVariable(refs)
	if err != nil {
		return false, err
	}
	
	return !isVar, nil
}

// generateConstructor generates a constructor function for a type
func generateConstructor(f *jen.File, structDef ssz.Field, schema *Schema) error {
	typeName := structDef.Name
	
	// Calculate total size
	_, totalSize, err := calculateOffsets(structDef, schema)
	if err != nil {
		return fmt.Errorf("failed to calculate size: %w", err)
	}
	
	f.Comment(fmt.Sprintf("New%s creates a new %s with the specified size", typeName, typeName))
	f.Func().Id("New" + typeName).Params().Id(typeName).Block(
		jen.Return(jen.Make(jen.Op("[]").Byte(), jen.Lit(totalSize))),
	)
	f.Line()
	
	// Generate constructor with parameters for each field
	var params []jen.Code
	var paramComments []string
	refs := make(map[string]ssz.Field)
	for _, s := range schema.Structs {
		refs[s.Name] = s.ToSSZField()
	}
	
	for _, field := range structDef.Children {
		paramName := field.Name
		switch field.Type {
		case ssz.TypeUint8:
			params = append(params, jen.Id(paramName).Uint8())
			paramComments = append(paramComments, fmt.Sprintf("%s: %s value", paramName, field.Type))
		case ssz.TypeUint16:
			params = append(params, jen.Id(paramName).Uint16())
			paramComments = append(paramComments, fmt.Sprintf("%s: %s value", paramName, field.Type))
		case ssz.TypeUint32:
			params = append(params, jen.Id(paramName).Uint32())
			paramComments = append(paramComments, fmt.Sprintf("%s: %s value", paramName, field.Type))
		case ssz.TypeUint64:
			params = append(params, jen.Id(paramName).Uint64())
			paramComments = append(paramComments, fmt.Sprintf("%s: %s value", paramName, field.Type))
		case ssz.TypeVector:
			// Check if this is a vector of uint8 (i.e., bytevector)
			if len(field.Children) > 0 && field.Children[0].Type == ssz.TypeUint8 {
				size := int(field.Size)
				params = append(params, jen.Id(paramName).Op("[").Lit(size).Op("]").Byte())
				paramComments = append(paramComments, fmt.Sprintf("%s: bytevector[%d] value", paramName, size))
			} else {
				// Handle other vector types
				params = append(params, jen.Id(paramName).Interface())
				paramComments = append(paramComments, fmt.Sprintf("%s: %s value", paramName, field.Type))
			}
		case ssz.TypeBitVector:
			byteSize := int((field.Size + 7) / 8)
			params = append(params, jen.Id(paramName).Op("[").Lit(byteSize).Op("]").Byte())
			paramComments = append(paramComments, fmt.Sprintf("%s: %s[%d] value (as %d bytes)", paramName, field.Type, field.Size, byteSize))
		case ssz.TypeRef:
			params = append(params, jen.Id(paramName).Id(field.Ref))
			paramComments = append(paramComments, fmt.Sprintf("%s: %s reference", paramName, field.Ref))
		default:
			return fmt.Errorf("unsupported field type %s in constructor", field.Type)
		}
	}
	
	// Generate comment for constructor with params
	f.Comment(fmt.Sprintf("New%sWithValues creates a new %s with the provided values", typeName, typeName))
	if len(paramComments) > 0 {
		f.Comment("Parameters:")
		for _, comment := range paramComments {
			f.Comment(fmt.Sprintf("  - %s", comment))
		}
	}
	
	// Generate the function
	f.Func().Id("New" + typeName + "WithValues").Params(params...).Id(typeName).BlockFunc(func(g *jen.Group) {
		// Create the object
		g.Id("obj").Op(":=").Id("New" + typeName).Call()
		
		// Set each field
		for _, field := range structDef.Children {
			setterName := "Set" + capitalizeFirst(field.Name)
			g.Id("obj").Dot(setterName).Call(jen.Id(field.Name))
		}
		
		g.Return(jen.Id("obj"))
	})
	f.Line()
	
	return nil
}

// generateMethods generates all methods for a type
func generateMethods(f *jen.File, structDef ssz.Field, schema *Schema) error {
	typeName := structDef.Name
	
	// Calculate offsets for each field
	offsets, totalSize, err := calculateOffsets(structDef, schema)
	if err != nil {
		return fmt.Errorf("failed to calculate offsets: %w", err)
	}
	
	// Generate Fixed method
	f.Comment("Fixed returns true if the type is fixed size")
	f.Func().Params(jen.Id("s").Id(typeName)).Id("Fixed").Params().Bool().Block(
		jen.Return(jen.Lit(true)),
	)
	f.Line()
	
	// Generate SizeSSZ method
	f.Comment("SizeSSZ returns the size of the serialized object")
	f.Func().Params(jen.Id("s").Id(typeName)).Id("SizeSSZ").Params().Int().Block(
		jen.Return(jen.Lit(totalSize)),
	)
	f.Line()
	
	// Generate MarshalSSZ method
	f.Comment("MarshalSSZ returns the bytes")
	f.Func().Params(jen.Id("s").Id(typeName)).Id("MarshalSSZ").Params().Params(jen.Op("[]").Byte(), jen.Error()).Block(
		jen.Comment("Check that the length matches the expected size"),
		jen.If(jen.Len(jen.Id("s")).Op("!=").Id("s").Dot("SizeSSZ").Call()).Block(
			jen.Return(
				jen.Nil(), 
				jen.Qual("github.com/gfx-labs/ssz", "NewSizeMismatchError").Call(
					jen.Id("s").Dot("SizeSSZ").Call(),
					jen.Len(jen.Id("s")),
				),
			),
		),
		jen.Return(jen.Id("s"), jen.Nil()),
	)
	f.Line()
	
	// Generate FillHashBuffer method
	if err := generateFillHashBuffer(f, typeName, structDef, schema); err != nil {
		return fmt.Errorf("failed to generate FillHashBuffer for %s: %w", structDef.Name, err)
	}
	
	// Generate HashSSZTo method
	f.Comment("HashSSZTo writes the merkle tree hash of the object to the provided buffer")
	f.Func().Params(jen.Id("s").Id(typeName)).Id("HashSSZTo").Params(jen.Id("buf").Op("[]").Byte()).Params(jen.Op("[]").Byte(), jen.Error()).Block(
		jen.Comment("Ensure buffer has at least 32 bytes"),
		jen.If(jen.Len(jen.Id("buf")).Op("<").Lit(32)).Block(
			jen.Return(jen.Nil(), jen.Qual("fmt", "Errorf").Call(jen.Lit("buffer too small: need at least 32 bytes, got %d"), jen.Len(jen.Id("buf")))),
		),
		jen.Comment("Allocate hash buffer for all fields"),
		jen.Id("numFields").Op(":=").Lit(len(structDef.Children)),
		jen.Id("hashBuffer").Op(":=").Make(jen.Op("[]").Byte(), jen.Id("numFields").Op("*").Lit(32)),
		jen.Comment("Fill the hash buffer with field hashes"),
		jen.If(jen.Err().Op(":=").Id("s").Dot("FillHashBuffer").Call(jen.Id("hashBuffer")), jen.Err().Op("!=").Nil()).Block(
			jen.Return(jen.Nil(), jen.Err()),
		),
		jen.Comment("Compute merkle root from the field hashes"),
		jen.If(jen.Err().Op(":=").Qual("github.com/gfx-labs/ssz/merkle_tree", "ComputeMerkleRoot").Call(jen.Id("hashBuffer"), jen.Id("hashBuffer")), jen.Err().Op("!=").Nil()).Block(
			jen.Return(jen.Nil(), jen.Err()),
		),
		jen.Comment("Copy the root hash to the provided buffer"),
		jen.Copy(jen.Id("buf"), jen.Id("hashBuffer").Op("[:32]")),
		jen.Return(jen.Id("buf").Op("[:32]"), jen.Nil()),
	)
	f.Line()
	
	// Generate HashSSZ method
	f.Comment("HashSSZ returns the merkle tree hash of the object")
	f.Func().Params(jen.Id("s").Id(typeName)).Id("HashSSZ").Params().Params(jen.Id("hash").Op("[32]").Byte(), jen.Id("err").Error()).Block(
		jen.Id("_").Op(",").Err().Op("=").Id("s").Dot("HashSSZTo").Call(jen.Id("hash").Op("[:]")),
		jen.Return(),
	)
	f.Line()
	
	// Generate getter methods for each field
	for i, field := range structDef.Children {
		if err := generateGetter(f, typeName, field, offsets[i], schema); err != nil {
			return fmt.Errorf("failed to generate getter for %s: %w", field.Name, err)
		}
	}
	
	// Generate setter methods for each field
	for i, field := range structDef.Children {
		if err := generateSetter(f, typeName, field, offsets[i], schema); err != nil {
			return fmt.Errorf("failed to generate setter for %s: %w", field.Name, err)
		}
	}
	
	return nil
}

// calculateOffsets calculates byte offsets for each field
func calculateOffsets(structDef ssz.Field, schema *Schema) ([]int, int, error) {
	refs := make(map[string]ssz.Field)
	for _, s := range schema.Structs {
		refs[s.Name] = s.ToSSZField()
	}
	
	offsets := make([]int, len(structDef.Children))
	currentOffset := 0
	
	for i, field := range structDef.Children {
		offsets[i] = currentOffset
		
		size, err := getFieldSize(field, refs)
		if err != nil {
			return nil, 0, fmt.Errorf("failed to get size for field %s: %w", field.Name, err)
		}
		
		currentOffset += size
	}
	
	return offsets, currentOffset, nil
}

// getFieldSize returns the size in bytes of a field
func getFieldSize(field ssz.Field, refs map[string]ssz.Field) (int, error) {
	switch field.Type {
	case ssz.TypeUint8, ssz.TypeBool:
		return 1, nil
	case ssz.TypeUint16:
		return 2, nil
	case ssz.TypeUint32:
		return 4, nil
	case ssz.TypeUint64:
		return 8, nil
	case ssz.TypeUint128:
		return 16, nil
	case ssz.TypeUint256:
		return 32, nil
	case ssz.TypeBitVector:
		return int((field.Size + 7) / 8), nil
	case ssz.TypeVector:
		// For vectors, calculate size based on element size * count
		if len(field.Children) > 0 {
			elemSize, err := getFieldSize(field.Children[0], refs)
			if err != nil {
				return 0, err
			}
			return elemSize * int(field.Size), nil
		}
		return 0, fmt.Errorf("vector %s has no element type", field.Name)
	case ssz.TypeRef:
		ref, ok := refs[field.Ref]
		if !ok {
			return 0, fmt.Errorf("ref type %s not found", field.Ref)
		}
		return getStructSize(ref, refs)
	case ssz.TypeContainer:
		return getStructSize(field, refs)
	default:
		return 0, fmt.Errorf("cannot get size for variable type %s", field.Type)
	}
}

// getStructSize calculates the total size of a struct
func getStructSize(structDef ssz.Field, refs map[string]ssz.Field) (int, error) {
	totalSize := 0
	for _, field := range structDef.Children {
		size, err := getFieldSize(field, refs)
		if err != nil {
			return 0, err
		}
		totalSize += size
	}
	return totalSize, nil
}

// generateGetter generates a getter method for a field
func generateGetter(f *jen.File, typeName string, field ssz.Field, offset int, schema *Schema) error {
	methodName := capitalizeFirst(field.Name)
	refs := make(map[string]ssz.Field)
	for _, s := range schema.Structs {
		refs[s.Name] = s.ToSSZField()
	}
	
	switch field.Type {
	case ssz.TypeUint8:
		f.Comment(fmt.Sprintf("%s returns the %s field", methodName, field.Name))
		f.Comment(fmt.Sprintf("Byte: %d", offset))
		f.Func().Params(jen.Id("s").Id(typeName)).Id(methodName).Params().Uint8().Block(
			jen.Return(jen.Id("s").Index(jen.Lit(offset))),
		)
		
	case ssz.TypeUint16:
		f.Comment(fmt.Sprintf("%s returns the %s field", methodName, field.Name))
		f.Comment(fmt.Sprintf("Bytes: %d-%d", offset, offset+1))
		f.Func().Params(jen.Id("s").Id(typeName)).Id(methodName).Params().Uint16().Block(
			jen.Return(jen.Qual("encoding/binary", "LittleEndian").Dot("Uint16").Call(
				jen.Id("s").Index(jen.Lit(offset).Op(":").Lit(offset+2)),
			)),
		)
		
	case ssz.TypeUint32:
		f.Comment(fmt.Sprintf("%s returns the %s field", methodName, field.Name))
		f.Comment(fmt.Sprintf("Bytes: %d-%d", offset, offset+3))
		f.Func().Params(jen.Id("s").Id(typeName)).Id(methodName).Params().Uint32().Block(
			jen.Return(jen.Qual("encoding/binary", "LittleEndian").Dot("Uint32").Call(
				jen.Id("s").Index(jen.Lit(offset).Op(":").Lit(offset+4)),
			)),
		)
		
	case ssz.TypeUint64:
		f.Comment(fmt.Sprintf("%s returns the %s field", methodName, field.Name))
		f.Comment(fmt.Sprintf("Bytes: %d-%d", offset, offset+7))
		f.Func().Params(jen.Id("s").Id(typeName)).Id(methodName).Params().Uint64().Block(
			jen.Return(jen.Qual("encoding/binary", "LittleEndian").Dot("Uint64").Call(
				jen.Id("s").Index(jen.Lit(offset).Op(":").Lit(offset+8)),
			)),
		)
		
	case ssz.TypeVector:
		// Check if this is a vector of uint8 (i.e., bytevector)
		if len(field.Children) > 0 && field.Children[0].Type == ssz.TypeUint8 {
			size := int(field.Size)
			f.Comment(fmt.Sprintf("%s returns the %s field", methodName, field.Name))
			f.Comment(fmt.Sprintf("Bytes: %d-%d", offset, offset+size-1))
			f.Func().Params(jen.Id("s").Id(typeName)).Id(methodName).Params().Op("[").Lit(size).Op("]").Byte().Block(
				jen.Return(jen.Op("[").Lit(size).Op("]").Byte().Call(
					jen.Id("s").Index(jen.Lit(offset).Op(":").Lit(offset+size)),
				)),
			)
		} else {
			// Handle other vector types generically
			f.Comment(fmt.Sprintf("%s returns the %s field", methodName, field.Name))
			f.Func().Params(jen.Id("s").Id(typeName)).Id(methodName).Params().Interface().Block(
				jen.Return(jen.Lit("TODO: implement vector getter")),
			)
		}
		
	case ssz.TypeBitVector:
		byteSize := int((field.Size + 7) / 8)
		endByte := offset + byteSize - 1
		f.Comment(fmt.Sprintf("%s returns the %s field", methodName, field.Name))
		if offset == endByte {
			f.Comment(fmt.Sprintf("Byte: %d", offset))
		} else {
			f.Comment(fmt.Sprintf("Bytes: %d-%d", offset, endByte))
		}
		f.Func().Params(jen.Id("s").Id(typeName)).Id(methodName).Params().Op("[").Lit(byteSize).Op("]").Byte().Block(
			jen.Return(jen.Op("[").Lit(byteSize).Op("]").Byte().Call(
				jen.Id("s").Index(jen.Lit(offset).Op(":").Lit(offset+byteSize)),
			)),
		)
		
	case ssz.TypeRef:
		size, err := getFieldSize(field, refs)
		if err != nil {
			return err
		}
		
		f.Comment(fmt.Sprintf("%s returns the %s field", methodName, field.Name))
		f.Comment(fmt.Sprintf("Bytes: %d-%d", offset, offset+size-1))
		f.Func().Params(jen.Id("s").Id(typeName)).Id(methodName).Params().Id(field.Ref).Block(
			jen.Return(jen.Id(field.Ref).Call(
				jen.Id("s").Index(jen.Lit(offset).Op(":").Lit(offset+size)),
			)),
		)
		
	default:
		return fmt.Errorf("unsupported field type %s for getter", field.Type)
	}
	
	f.Line()
	return nil
}

// generateSetter generates a setter method for a field
func generateSetter(f *jen.File, typeName string, field ssz.Field, offset int, schema *Schema) error {
	methodName := "Set" + capitalizeFirst(field.Name)
	refs := make(map[string]ssz.Field)
	for _, s := range schema.Structs {
		refs[s.Name] = s.ToSSZField()
	}
	
	switch field.Type {
	case ssz.TypeUint8:
		f.Comment(fmt.Sprintf("%s sets the %s field", methodName, field.Name))
		f.Comment(fmt.Sprintf("Byte: %d", offset))
		f.Func().Params(jen.Id("s").Id(typeName)).Id(methodName).Params(jen.Id("v").Uint8()).Block(
			jen.Id("s").Index(jen.Lit(offset)).Op("=").Id("v"),
		)
		
	case ssz.TypeUint16:
		f.Comment(fmt.Sprintf("%s sets the %s field", methodName, field.Name))
		f.Comment(fmt.Sprintf("Bytes: %d-%d", offset, offset+1))
		f.Func().Params(jen.Id("s").Id(typeName)).Id(methodName).Params(jen.Id("v").Uint16()).Block(
			jen.Qual("encoding/binary", "LittleEndian").Dot("PutUint16").Call(
				jen.Id("s").Index(jen.Lit(offset).Op(":").Lit(offset+2)),
				jen.Id("v"),
			),
		)
		
	case ssz.TypeUint32:
		f.Comment(fmt.Sprintf("%s sets the %s field", methodName, field.Name))
		f.Comment(fmt.Sprintf("Bytes: %d-%d", offset, offset+3))
		f.Func().Params(jen.Id("s").Id(typeName)).Id(methodName).Params(jen.Id("v").Uint32()).Block(
			jen.Qual("encoding/binary", "LittleEndian").Dot("PutUint32").Call(
				jen.Id("s").Index(jen.Lit(offset).Op(":").Lit(offset+4)),
				jen.Id("v"),
			),
		)
		
	case ssz.TypeUint64:
		f.Comment(fmt.Sprintf("%s sets the %s field", methodName, field.Name))
		f.Comment(fmt.Sprintf("Bytes: %d-%d", offset, offset+7))
		f.Func().Params(jen.Id("s").Id(typeName)).Id(methodName).Params(jen.Id("v").Uint64()).Block(
			jen.Qual("encoding/binary", "LittleEndian").Dot("PutUint64").Call(
				jen.Id("s").Index(jen.Lit(offset).Op(":").Lit(offset+8)),
				jen.Id("v"),
			),
		)
		
		
	case ssz.TypeVector:
		// Check if this is a vector of uint8 (i.e., bytevector)
		if len(field.Children) > 0 && field.Children[0].Type == ssz.TypeUint8 {
			size := int(field.Size)
			f.Comment(fmt.Sprintf("%s sets the %s field", methodName, field.Name))
			f.Comment(fmt.Sprintf("Bytes: %d-%d", offset, offset+size-1))
			f.Func().Params(jen.Id("s").Id(typeName)).Id(methodName).Params(jen.Id("v").Op("[").Lit(size).Op("]").Byte()).Block(
				jen.Copy(jen.Id("s").Index(jen.Lit(offset).Op(":").Lit(offset+size)), jen.Id("v").Index(jen.Op(":"))),
			)
		} else {
			// Handle other vector types generically
			f.Comment(fmt.Sprintf("%s sets the %s field", methodName, field.Name))
			f.Func().Params(jen.Id("s").Id(typeName)).Id(methodName).Params(jen.Id("v").Interface()).Block(
				jen.Comment("TODO: implement vector setter"),
			)
		}
		
	case ssz.TypeBitVector:
		byteSize := int((field.Size + 7) / 8)
		endByte := offset + byteSize - 1
		f.Comment(fmt.Sprintf("%s sets the %s field", methodName, field.Name))
		if offset == endByte {
			f.Comment(fmt.Sprintf("Byte: %d", offset))
		} else {
			f.Comment(fmt.Sprintf("Bytes: %d-%d", offset, endByte))
		}
		f.Func().Params(jen.Id("s").Id(typeName)).Id(methodName).Params(jen.Id("v").Op("[").Lit(byteSize).Op("]").Byte()).Block(
			jen.Copy(jen.Id("s").Index(jen.Lit(offset).Op(":").Lit(offset+byteSize)), jen.Id("v").Index(jen.Op(":"))),
		)
		
	case ssz.TypeRef:
		size, err := getFieldSize(field, refs)
		if err != nil {
			return err
		}
		
		f.Comment(fmt.Sprintf("%s sets the %s field", methodName, field.Name))
		f.Comment(fmt.Sprintf("Bytes: %d-%d", offset, offset+size-1))
		f.Func().Params(jen.Id("s").Id(typeName)).Id(methodName).Params(jen.Id("v").Id(field.Ref)).Block(
			jen.Copy(jen.Id("s").Index(jen.Lit(offset).Op(":").Lit(offset+size)), jen.Id("v")),
		)
		
	default:
		return fmt.Errorf("unsupported field type %s for setter", field.Type)
	}
	
	f.Line()
	return nil
}

// generateFillHashBuffer generates the FillHashBuffer method for a type
func generateFillHashBuffer(f *jen.File, typeName string, structDef ssz.Field, schema *Schema) error {
	refs := make(map[string]ssz.Field)
	for _, s := range schema.Structs {
		refs[s.Name] = s.ToSSZField()
	}
	
	offsets, _, err := calculateOffsets(structDef, schema)
	if err != nil {
		return err
	}
	
	f.Comment("FillHashBuffer fills the provided buffer with hashes of all fields")
	
	// Build the body statements
	bodyStatements := []jen.Code{
		jen.Comment("Ensure buffer is large enough"),
		jen.If(jen.Len(jen.Id("buf")).Op("<").Lit(len(structDef.Children)*32)).Block(
			jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("buffer too small: need %d bytes, got %d"), jen.Lit(len(structDef.Children)*32), jen.Len(jen.Id("buf")))),
		),
		jen.Line(),
		jen.Comment("Hash each field and store in buffer"),
	}
	bodyStatements = append(bodyStatements, generateFieldHashing(structDef, offsets, refs)...)
	
	f.Func().Params(jen.Id("s").Id(typeName)).Id("FillHashBuffer").Params(jen.Id("buf").Op("[]").Byte()).Error().Block(
		bodyStatements...,
	)
	f.Line()
	
	return nil
}

// generateFieldHashing generates the code to hash each field
func generateFieldHashing(structDef ssz.Field, offsets []int, refs map[string]ssz.Field) []jen.Code {
	var statements []jen.Code
	
	for i, field := range structDef.Children {
		fieldOffset := offsets[i]
		bufOffset := i * 32
		
		switch field.Type {
		case ssz.TypeUint8, ssz.TypeUint16, ssz.TypeUint32, ssz.TypeUint64:
			// For small integers, copy directly to the buffer with padding
			size, _ := getFieldSize(field, refs)
			statements = append(statements,
				jen.Comment(fmt.Sprintf("Field %s (%s)", field.Name, field.Type)),
				jen.Copy(jen.Id("buf").Index(jen.Lit(bufOffset), jen.Lit(bufOffset+size)), jen.Id("s").Index(jen.Lit(fieldOffset), jen.Lit(fieldOffset+size))),
			)
			// Zero padding for the rest of the 32 bytes
			if size < 32 {
				statements = append(statements,
					jen.For(jen.Id("j").Op(":=").Lit(bufOffset+size), jen.Id("j").Op("<").Lit(bufOffset+32), jen.Id("j").Op("++")).Block(
						jen.Id("buf").Index(jen.Id("j")).Op("=").Lit(0),
					),
				)
			}
			
		case ssz.TypeUint128, ssz.TypeUint256:
			// For larger integers, copy directly
			size, _ := getFieldSize(field, refs)
			statements = append(statements,
				jen.Comment(fmt.Sprintf("Field %s (%s)", field.Name, field.Type)),
				jen.Copy(jen.Id("buf").Index(jen.Lit(bufOffset), jen.Lit(bufOffset+size)), jen.Id("s").Index(jen.Lit(fieldOffset), jen.Lit(fieldOffset+size))),
			)
			
		case ssz.TypeBool:
			// For booleans, copy single byte with padding
			statements = append(statements,
				jen.Comment(fmt.Sprintf("Field %s (bool)", field.Name)),
				jen.Id("buf").Index(jen.Lit(bufOffset)).Op("=").Id("s").Index(jen.Lit(fieldOffset)),
				jen.For(jen.Id("j").Op(":=").Lit(bufOffset+1), jen.Id("j").Op("<").Lit(bufOffset+32), jen.Id("j").Op("++")).Block(
					jen.Id("buf").Index(jen.Id("j")).Op("=").Lit(0),
				),
			)
			
		case ssz.TypeBitVector:
			// For bit vectors, we need to hash the bytes
			size, _ := getFieldSize(field, refs)
			statements = append(statements,
				jen.Comment(fmt.Sprintf("Field %s (%s, size %d)", field.Name, field.Type, field.Size)),
			)
			
			// If size is <= 32, copy directly with padding
			if size <= 32 {
				statements = append(statements,
					jen.Copy(jen.Id("buf").Index(jen.Lit(bufOffset), jen.Lit(bufOffset+size)), jen.Id("s").Index(jen.Lit(fieldOffset), jen.Lit(fieldOffset+size))),
				)
				if size < 32 {
					statements = append(statements,
						jen.For(jen.Id("j").Op(":=").Lit(bufOffset+size), jen.Id("j").Op("<").Lit(bufOffset+32), jen.Id("j").Op("++")).Block(
							jen.Id("buf").Index(jen.Id("j")).Op("=").Lit(0),
						),
					)
				}
			} else {
				// For larger byte vectors, compute hash
				statements = append(statements,
					jen.Block(
						jen.Id("fieldData").Op(":=").Id("s").Index(jen.Lit(fieldOffset), jen.Lit(fieldOffset+size)),
						jen.Id("root").Op(",").Err().Op(":=").Qual("github.com/gfx-labs/ssz/merkle_tree", "BytesRoot").Call(jen.Id("fieldData")),
						jen.If(jen.Err().Op("!=").Nil()).Block(
							jen.Return(jen.Err()),
						),
						jen.Copy(jen.Id("buf").Index(jen.Lit(bufOffset), jen.Lit(bufOffset+32)), jen.Id("root").Op("[:]")),
					),
				)
			}
			
		case ssz.TypeRef:
			// For references, we need to recursively hash the referenced type
			ref, ok := refs[field.Ref]
			if !ok {
				return append(statements, jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit(fmt.Sprintf("ref type %s not found", field.Ref)))))
			}
			refSize, _ := getStructSize(ref, refs)
			statements = append(statements,
				jen.Comment(fmt.Sprintf("Field %s (ref to %s)", field.Name, field.Ref)),
				jen.Block(
					jen.Id("refData").Op(":=").Id(field.Ref).Call(jen.Id("s").Index(jen.Lit(fieldOffset), jen.Lit(fieldOffset+refSize))),
					jen.Id("_").Op(",").Err().Op(":=").Id("refData").Dot("HashSSZTo").Call(jen.Id("buf").Index(jen.Lit(bufOffset), jen.Lit(bufOffset+32))),
					jen.If(jen.Err().Op("!=").Nil()).Block(
						jen.Return(jen.Err()),
					),
				),
			)
			
		case ssz.TypeVector:
			// Check if this is a vector of uint8 (i.e., bytevector)
			if len(field.Children) > 0 && field.Children[0].Type == ssz.TypeUint8 {
				// For byte vectors, we need to hash the bytes - same as bitvector
				size, _ := getFieldSize(field, refs)
				statements = append(statements,
					jen.Comment(fmt.Sprintf("Field %s (bytevector, size %d)", field.Name, field.Size)),
				)
				
				// If size is <= 32, copy directly with padding
				if size <= 32 {
					statements = append(statements,
						jen.Copy(jen.Id("buf").Index(jen.Lit(bufOffset), jen.Lit(bufOffset+size)), jen.Id("s").Index(jen.Lit(fieldOffset), jen.Lit(fieldOffset+size))),
					)
					// Pad remaining bytes with zeros if needed
					if size < 32 {
						statements = append(statements,
							jen.For(jen.Id("j").Op(":=").Lit(bufOffset+size), jen.Id("j").Op("<").Lit(bufOffset+32), jen.Id("j").Op("++")).Block(
								jen.Id("buf").Index(jen.Id("j")).Op("=").Lit(0),
							),
						)
					}
				} else {
					// For larger sizes, we need to hash in chunks
					statements = append(statements,
						jen.Comment("TODO: implement chunked hashing for large bytevectors"),
						jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit(fmt.Sprintf("bytevector size %d > 32 not yet supported", size)))),
					)
				}
			} else {
				statements = append(statements,
					jen.Comment(fmt.Sprintf("Field %s (vector type not yet supported)", field.Name)),
					jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit(fmt.Sprintf("vector field type not yet supported: %s", field.Type)))),
				)
			}
			
		default:
			statements = append(statements,
				jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit(fmt.Sprintf("unsupported field type: %s", field.Type)))),
			)
		}
		
		statements = append(statements, jen.Line())
	}
	
	statements = append(statements, jen.Return(jen.Nil()))
	return statements
}

// capitalizeFirst capitalizes the first letter of a string
func capitalizeFirst(s string) string {
	if s == "" {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}